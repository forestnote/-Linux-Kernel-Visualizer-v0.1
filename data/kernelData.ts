import type { KernelNode } from '../types';

/**
 * The root node of the Linux kernel data structure.
 * This object contains the entire hierarchical tree of files and directories,
 * along with their summaries and detailed descriptions.
 * @type {KernelNode}
 */
export const kernelData: KernelNode = {
  name: 'linux/',
  summary: 'カーネルソースツリーのルート',
  description: 'Linuxカーネルのソースコード全体を格納する最上位ディレクトリです。ここには、カーネルのビルドプロセス全体を統括するトップレベルの`Makefile`、カーネルのコンパイルオプションを定義する`Kconfig`ファイル群、そしてカーネルを構成するすべてのサブシステムを含むサブディレクトリが配置されています。Linuxカーネルの開発は、このディレクトリ構造を基盤として、世界中の開発者による分散作業として進められています。\n\nビルドプロセスは非常に洗練されており、`make`コマンドがこのトップレベルの`Makefile`を読み込むことから始まります。Makefileは`.config`ファイル（`make menuconfig`などで生成される）を参照し、有効化された機能やドライバに対応するサブディレクトリのみを再帰的にビルドします。`Kconfig`ファイル群は、各オプション間の複雑な依存関係を定義しており、例えば特定のネットワークカードドライバを選択すると、コアネットワークスタックやPCIバスサポートが自動的に有効になる、といった整合性を保証します。この柔軟かつ強力なビルドシステムが、組み込みデバイスからスーパーコンピュータまで、多種多様なターゲットに対応したカーネルの構築を可能にしています。',
  children: [
    {
      name: 'arch/',
      summary: 'アーキテクチャ固有のコード',
      description: '特定のCPUアーキテクチャに依存するコードを体系的に格納するディレクトリです。各サブディレクトリ（例: `x86`, `arm64`, `riscv`）は、それぞれのプロセッサファミリーに対応しています。ここに含まれるコードは、カーネルの起動シーケンスの最も初期の段階、メモリ管理ユニット(MMU)の低レベルな操作、ページテーブルの形式、割り込みハンドリングのメカニズム、システムコールのインターフェース実装など、ハードウェアの仕様に深く根差した部分を担当します。このディレクトリの存在が、Linuxの優れた移植性を実現する鍵であり、汎用的なC言語で書かれたカーネル本体のコードと、具体的なハードウェアとの間の重要な橋渡し役を担っています。\n\n例えば、プロセスがシステムコールを発行した際、ユーザモードからカーネルモードへの遷移方法はアーキテクチャ毎に異なります（x86では`syscall`命令、ARMでは`svc`命令など）。`arch/`以下のコードが、これらの命令を捕捉し、ユーザ空間のレジスタを保存し、カーネルスタックに切り替えてから、アーキテクチャ非依存の共通システムコールハンドラを呼び出す、という一連の処理を実装しています。同様に、プロセスのコンテキストスイッチ（`switch_to`マクロ）も、どのレジスタを保存・復元する必要があるかがCPUに強く依存するため、ここでアセンブリ言語を用いて実装されることが多く、OSの性能に直結する非常に重要な部分です。',
      children: [
        { 
          name: 'x86/', 
          summary: 'x86 (32/64-bit) プロセッサ用のコード', 
          description: 'IntelおよびAMDの32ビット(i386)および64ビット(x86_64)プロセッサファミリに特化したアーキテクチャ固有コードです。ブートプロトコルの詳細な実装、セグメンテーションやページングといったメモリ管理機構のセットアップ、システムコールを発行するための`syscall`/`sysenter`命令のエントリポイント、割り込みディスクリプタテーブル(IDT)の初期化と管理など、x86プラットフォームの核心的な機能を実装しています。近年のCPUで追加された新しい命令セット（AVXなど）やセキュリティ機能（SGX, SMEP/SMAP）への対応もここで行われます。\n\n具体的には、IDTはCPU例外（ページフォールト、一般保護違反など）やハードウェア割り込みが発生した際に、CPUがどのハンドラを呼び出すべきかを定義する重要なテーブルです。このディレクトリのコードがIDTを適切に設定し、各エントリポイントでレジスタを保存するなどの定型処理を行った後、より高レベルなC言語で書かれた共通ハンドラへと処理を繋ぎます。また、SpectreやMeltdownといったCPUの投機的実行に起因する脆弱性に対する複雑な緩和策（リターンポリンなど）も、このアーキテクチャ固有の層に実装されており、現代のOSにおけるセキュリティの最前線となっています。',
          children: [
            { name: 'boot/', summary: 'ブートローダ関連コード', description: 'カーネルイメージをメモリにロードし、実行を開始するためのブートストラップコード群です。GRUBのようなブートローダから制御を受け取った後、`bzImage`のような圧縮されたカーネルイメージを展開し、CPUをリアルモードからプロテクトモード、そして64ビット環境ではロングモードへと移行させます。カーネル本体のC言語コード(`start_kernel`)が実行可能になる前の、最も低レベルな初期設定（GDT/IDTの仮設定、ページングの有効化など）を担う、極めて重要な部分です。\n\nこの初期段階では、まだC言語の実行環境が完全に整っていないため、多くのコードがアセンブリ言語で記述されています。例えば、最初の数ページ分の物理メモリをマッピングするための仮のページテーブルを作成し、ページング機能を有効にすることで、カーネル自身が仮想アドレス空間で動作できるようにします。この処理が完了して初めて、カーネルは高位メモリに展開され、C言語で書かれた主要な初期化ルーチンへとジャンプすることができるのです。'},
            { name: 'kernel/', summary: 'x86固有のコアカーネルコード', description: 'x86アーキテクチャに特化したOSの中核機能が実装されています。`cpuid`命令を用いたCPU機能の検出と初期化、割り込みコントローラ(APIC)の管理、タスクステートセグメント(TSS)の設定、プロセスコンテキストの切り替えを行う`switch_to`マクロの実装、シグナルハンドラを呼び出す際のスタックフレームの構築など、アーキテクチャ依存性の高いOSの根幹をなす処理が含まれています。\n\nTSSは、特にハードウェアによるタスクスイッチ（現在はほとんど使われない）や、CPU例外が発生した際に使用するカーネルスタックポインタをCPUに知らせるために重要です。`switch_to`マクロは、スケジューラが次に実行すべきプロセスを決定した後に呼び出され、現在のプロセスのCPUレジスタ（命令ポインタ、スタックポインタ、汎用レジスタなど）をメモリ（`task_struct`内）に保存し、次のプロセスのレジスタをCPUにロードすることで、実行コンテキストの切り替えを完了させます。これはOSのマルチタスク機能の心臓部です。'},
            { name: 'mm/', summary: 'x86固有のメモリ管理コード', description: 'x86アーキテクチャのページングメカニズムを直接操作するコードです。64ビットモードにおける4レベルまたは5レベルのページテーブル(PML4, PDPT, PD, PT)の作成、更新、および階層的な探索を行います。また、TLB(Translation Lookaside Buffer)の無効化処理や、物理アドレス拡張(PAE)のサポートなど、仮想メモリを物理メモリにマッピングするための低レベルかつパフォーマンスに直結する実装が集まっています。\n\nプロセスが新しいメモリ領域を確保したり、`fork()`で子プロセスを作成したりする際には、このコードがページテーブルエントリ(PTE)を適切に設定します。PTEには物理ページのアドレスだけでなく、アクセス権（読み取り/書き込み/実行可否）、キャッシュポリシー、ダーティビット（書き込みがあったか）などの重要な情報も含まれます。TLBは仮想-物理アドレス変換を高速化するキャッシュですが、ページテーブルが変更された際には、古いキャッシュが残らないように明示的にTLBエントリを無効化（フラッシュ）する必要があり、その処理もここで実装されています。'},
            { name: 'entry/', summary: 'システムコールと例外エントリ', description: 'ユーザースペースからカーネルスペースへの主要な遷移点、すなわちシステムコールとCPU例外（ページフォールト、一般保護違反など）のハンドラへのエントリポイントを定義します。多くはアセンブリ言語で記述されており、ユーザースペースのレジスタを保存し、カーネルスタックに切り替え、適切なC言語のハンドラ関数を呼び出すという、コンテキストスイッチの最初のステップを担います。セキュリティ脆弱性が生まれやすい箇所でもあるため、Spectreなどのサイドチャネル攻撃への対策コードも含まれています。\n\n`entry_SYSCALL_64.S`のようなファイルがこの役割の中心です。`syscall`命令が実行されると、CPUは事前に登録されたアドレス（MSRレジスタで設定）にジャンプします。このエントリコードは、システムコール番号を基に、システムコールテーブルから対応するハンドラ関数のアドレスを検索し、呼び出します。この一連の処理は、ユーザ空間とカーネル空間という特権レベルの異なるドメイン間の安全な橋渡しであり、その効率性はシステム全体のパフォーマンスに直接影響します。'},
            { name: 'pci/', summary: 'x86固有のPCIサポート', description: 'x86プラットフォームにおけるPCIバスの初期化とリソース割り当てのロジックです。BIOSやUEFIファームウェアとの連携、I/OポートやメモリマップドI/O(MMIO)空間へのアクセス方法など、プラットフォーム依存性の高い部分を扱います。汎用のPCIドライバフレームワークと連携し、デバイスの検出と設定を行います。\n\nx86では歴史的に、I/Oポート空間とメモリ空間という2つの異なるアドレス空間が存在します。PCIデバイスは、自身のレジスタをこれらの空間にマッピングするよう要求します。このコードは、ACPIテーブルなどを読み取り、他のデバイスと競合しないように各デバイスにアドレス範囲を割り当てます。このリソース割り当てが完了して初めて、汎用のデバイスドライバがMMIOやI/Oポートを通じてデバイスと通信できるようになります。'},
            { name: 'kvm/', summary: 'x86用KVM実装', description: 'x86アーキテクチャのハードウェア仮想化支援機能(Intel VT-x, AMD-V)を直接利用するためのKVM (Kernel-based Virtual Machine) のバックエンドコードです。VMX/SVM命令を駆使してゲストVMの実行コンテキスト(VMCS/VMCB)を管理し、ゲストVMの実行と停止(VM entry/VM exit)を制御します。VM exitが発生した際のハンドリング(シャドウページテーブルの管理、エミュレートされたデバイスI/Oの処理など)を実装し、QEMUのようなユーザースペースのVMMと協調して動作します。\n\nVM exitは、ゲストOSが特権命令を実行しようとしたり、外部割り込みが発生したりした場合に起こる、ゲストからホストへの制御の移行です。KVMのこの部分は、VM exitの理由を解析し、それをエミュレートします。例えば、ゲストが仮想NICに書き込もうとした場合、KVMはその処理を捕捉し、ユーザースペースのQEMUに通知します。QEMUがそのI/Oをエミュレートし、結果をKVMに返します。このホストとゲスト間の効率的な連携が、KVMの高いパフォーマンスの鍵です。' },
          ]
        },
        { name: 'arm64/', summary: '64-bit ARM プロセッサ用のコード', description: 'スマートフォン、タブレット、そして近年ではサーバー市場でも広く採用されている64ビットARM(AArch64)アーキテクチャ用のコードです。プロセッサの実行レベルであるException Level (EL0-EL3) の管理、割り込み処理、メモリ管理モデル（4KB, 16KB, 64KBのページ粒度サポート）、そしてbig.LITTLEのようなヘテロジニアスなCPU構成への対応など、ARMv8/v9アーキテクチャに固有の機能に対応するための実装が含まれています。\n\nARMアーキテクチャでは、x86とは異なる割り込みコントローラ(GIC - Generic Interrupt Controller)やタイマーが使用されます。このディレクトリのコードは、これらのハードウェアを初期化し、汎用カーネルフレームワークに組み込みます。また、big.LITTLE構成では、性能重視の「big」コアと電力効率重視の「LITTLE」コアが混在するため、スケジューラがタスクの性質に応じて適切なコアに割り当てるためのアーキテクチャ固有のサポート（Energy Aware Schedulingなど）もここで提供されます。' },
        { name: 'riscv/', summary: 'RISC-Vアーキテクチャ用のコード', description: 'オープンな命令セットアーキテクチャ(ISA)として注目を集めるRISC-V用のポートです。マシンモードのファームウェア(OpenSBIなど)との通信インターフェースであるSupervisor Binary Interface (SBI) の呼び出し、Platform-Level Interrupt Controller (PLIC) の制御、メモリ管理など、RISC-Vプラットフォーム上でLinuxを実行するための基盤を提供します。ISAがモジュール化されているため、様々な拡張命令セットへの対応もここで行われます。\n\nRISC-Vは特権レベル（マシンモード、スーパーバイザモード、ユーザモード）が明確に定義されており、Linuxカーネルはスーパーバイザモードで動作します。カーネルがハードウェアを直接操作する必要がある場合（例：タイマーの設定、プロセッサ間割り込みの送信）、カーネルはSBIコールを発行して、より高い特権レベルであるマシンモードで動作するファームウェアに処理を依頼します。この明確な責務分離が、RISC-Vプラットフォームの設計をクリーンに保つ一助となっています。' },
        { name: '...', summary: '他のサポートされているアーキテクチャ', description: 'MIPS, PowerPC, s390 (IBM Z), SPARCなど、Linuxがサポートする多様なCPUアーキテクチャ用のコードがここに存在します。Linuxがサーバーから組み込みシステム、メインフレームまで、幅広いプラットフォームで動作する理由がここにあります。これらのアーキテクチャ固有のコードは、Linuxの優れた移植性と設計の柔軟性を明確に示しています。\n\n各アーキテクチャは、それぞれ固有のブートプロセス、メモリ管理ユニット、割り込みシステム、システムコールインターフェースを持っています。`arch/`以下のコードがこれらの差異を吸収し、その上のカーネルの大部分（`fs/`, `net/`, `mm/`など）に対して、統一されたインターフェースを提供します。このクリーンな抽象化レイヤこそが、新しいCPUアーキテクチャへの移植を比較的容易にし、Linuxの成功を支える技術的な基盤の一つです。' },
      ],
    },
    {
      name: 'block/',
      summary: 'ブロックI/Oレイヤー',
      description: 'ハードディスクやSSD、SDカードなどのブロックデバイスとのデータ入出力を抽象化し、管理するサブシステムです。ファイルシステムからのI/O要求を、`bio`という基本I/O単位構造体に変換し、さらにこれを`request`構造体にまとめてリクエストキューに入れます。I/Oスケジューラ（現在はBFQやKyberが主流）が、これらのリクエストをマージ（結合）したり、並べ替えたりすることで、ディスクヘッドのシークを最小化し、全体的なスループットを向上させます。マルチキューブロックレイヤ(blk-mq)の導入により、現代の高速なNVMe SSDが持つ並列処理能力を最大限に引き出す設計になっています。\n\n`bio`構造体は、特定のブロックデバイスの特定のセクタに対する読み書き操作を表す、単純なI/O要求です。一方、`request`構造体は、I/Oスケジューラが操作する、より複雑な単位です。例えば、隣接するセクタへの複数の`bio`は、単一の`request`にマージされることがあります。`blk-mq`では、CPUコアごとに専用のサブミッションキューを用意し、キュー間のロック競合を排除することで、マルチコア環境でのI/O性能を劇的に向上させました。これにより、数百万IOPSを誇る最新のSSDの性能を、ソフトウェアのオーバーヘッドで妨げることなく引き出すことが可能になっています。',
    },
    {
      name: 'certs/',
      summary: '署名検証用証明書',
      description: 'UEFIセキュアブート環境などで、カーネル本体やロードされるカーネルモジュールのデジタル署名を検証するために使用されるX.509証明書を格納します。カーネルのビルド時に、信頼された鍵（トラストアンカー）をカーネルイメージ内に組み込むことができます。これにより、信頼されたベンダーによって署名されていない、あるいは改ざんされたコードの実行を防ぎ、システムの起動プロセス全体の完全性（Chain of Trust）を高めるための重要な役割を果たします。\n\nセキュアブートが有効なシステムでは、UEFIファームウェアがまずブートローダの署名を検証します。次に、ブートローダがカーネルイメージの署名を、カーネルに組み込まれた公開鍵を使って検証します。さらに、カーネルは`insmod`でロードされるカーネルモジュールの署名を検証します。この連鎖的な検証プロセスにより、システムの起動から実行に至るまで、悪意のあるコードが介在する余地を排除し、システムの信頼性を根本から確保します。このディレクトリは、その信頼の起点となる証明書を管理する場所です。',
    },
    {
      name: 'crypto/',
      summary: '暗号化フレームワーク',
      description: 'カーネル内で利用可能な統一された暗号化機能を提供するAPIと、各種暗号アルゴリズムの実装です。AES, ChaCha20などの対称暗号、RSA, ECCなどの非対称暗号、SHA-256, BLAKE2などのハッシュ関数、HMACのようなメッセージ認証コードなど、幅広い暗号プリミティブを提供します。ファイルシステムの暗号化(dm-crypt/LUKS, fscrypt)、ネットワーク通信のセキュリティ(IPsec, WireGuard)、乱数生成など、他の多くのカーネルサブシステムから利用されます。CPUが持つ暗号化支援命令（AES-NIなど）を利用したハードウェアアクセラレーションにも対応しており、高いパフォーマンスを実現します。\n\nこのフレームワークの重要な特徴は、同期APIと非同期APIの両方を提供している点です。同期APIは呼び出しが完了するまでブロックしますが、非同期APIは処理要求をキューに入れ、完了後にコールバック関数を呼び出すため、呼び出し元は他の処理を並行して進めることができます。特に、専用の暗号化ハードウェアアクセラレータを持つシステムでは、この非同期インターフェースが性能を最大限に引き出す鍵となります。`dm-crypt`のようなブロックレイヤでの暗号化処理は、このAPIを通じてハードウェアにオフロードされ、CPU負荷を低減しつつ高いスループットを維持します。',
    },
    {
      name: 'Documentation/',
      summary: 'カーネルのドキュメント',
      description: 'Linuxカーネルの内部API、サブシステムの設計、ユーザー向け機能、開発プロセスなどに関する膨大な量のドキュメントを格納するディレクトリです。Sphinxツールセットを用いてHTMLやPDF形式でビルドできるようになっており、カーネル開発者や上級ユーザーにとって最も重要な情報源の一つです。カーネルの各機能の正しい使い方や、新しいコードをコントリビューートする際のルールなどを理解するために不可欠です。\n\n以前はプレーンテキストファイルが散在していましたが、近年ReStructuredText (RST) 形式への移行が進み、構造化された読みやすいドキュメントが整備されつつあります。`make htmldocs`のようなコマンドを実行することで、ソースツリーから直接、相互にリンクされた高品質なドキュメントサイトを生成できます。カーネルのコードを読解する際には、まずこのディレクトリの関連ドキュメントに目を通すことが、全体像を理解するための近道となることが多いです。',
      children: [
        { name: 'process/', summary: '開発プロセスとコーディング規約', description: 'Linuxカーネルの開発プロセス、パッチの提出方法、コーディングスタイルガイドライン、メンテナの役割など、カーネル開発に参加するために必要な情報がまとめられています。特に`coding-style.rst`は、全てのカーネルコントリビュータが従うべきコーディング規約を詳細に定めています。\n\nこの規約は、インデント（タブ、8文字幅）、命名規則、コメントの書き方など、コードの見た目に関するルールだけでなく、関数は短く保つべき、グローバル変数を無闇に使うべきではない、といった設計に関する哲学も含まれています。世界中の何千人もの開発者が共同作業を行う巨大なプロジェクトにおいて、コードの一貫性と可読性を維持するための、極めて重要な文書です。' },
        { name: 'core-api/', summary: 'コアカーネルAPIドキュメント', description: 'カーネルの基本的なAPI（リスト操作、ロック、メモリ管理など）に関するリファレンスドキュメントです。カーネルモジュールやサブシステムを開発する際に、これらのAPIがどのように機能し、どのように正しく使用すべきかを解説しています。\n\n例えば、`locking/`サブディレクトリには、スピンロック、ミューテックス、セマフォなどの同期プリミティブの正しい使い方、特にデッドロックを避けるための注意点や、割り込みコンテキストで使用可能なロックの種類などが詳細に説明されています。これらのAPIを誤って使用すると、システム全体のデッドロックやデータ破損に繋がるため、このドキュメントはカーネルプログラミングの安全性を確保する上で不可欠です。' },
        { name: 'admin-guide/', summary: 'システム管理者向けガイド', description: 'カーネルの各種機能のチューニング方法や設定方法について、システム管理者向けに解説したドキュメントです。sysctlパラメータ、カーネルコマンドラインオプション、sysfsインターフェースの使い方などが含まれます。\n\n例えば、`kernel-parameters.rst`には、カーネル起動時にブートローダから渡すことができる数百ものパラメータがリストアップされており、それぞれがシステムの動作にどのような影響を与えるかが説明されています。これにより、特定のハードウェアの問題を回避したり、特定のワークロードに合わせてパフォーマンスを最適化したりするなど、システムの挙動を細かく制御することが可能になります。' },
      ],
    },
    {
      name: 'drivers/',
      summary: 'デバイスドライバ',
      description: 'Linuxカーネルのソースコードで最も大きな部分（全体の50%以上）を占め、物理的または仮想的なハードウェアデバイスを制御するための膨大なコードが集まっています。ドライバは、デバイスの検出と初期化、IRQやDMAチャネル、メモリマップドI/O領域といったハードウェアリソースの割り当て、デバイスとのデータ送受信、省電力管理などを担当します。Linuxのデバイスモデルは、バス(Bus)、ドライバ(Driver)、デバイス(Device)の3つの主要なオブジェクトで構成されており、`sysfs`を通じてユーザースペースにデバイスの階層構造を可視化します。この柔軟なドライバモデルが、Linuxが多種多様なハードウェアをサポートできる理由です。\n\nデバイスドライバの初期化は「プローブ(probe)」関数で行われます。カーネルは、PCIバスなどをスキャンしてデバイスを発見すると、そのデバイスのID（ベンダーID、デバイスIDなど）に一致するドライバを探します。一致するドライバが見つかると、そのドライバのプローブ関数を呼び出します。プローブ関数内で、ドライバはデバイスが正常に動作することを確認し、必要なリソース（メモリ、IRQなど）を確保し、デバイスを動作可能な状態にします。この仕組みにより、システムに接続されているデバイスに必要なドライバだけがロードされ、実行されるようになっています。',
      children: [
        { name: 'ata/', summary: 'ATA/SATAデバイス用ドライバ', description: '旧来のPATA (Parallel ATA or IDE) および現代的なSATA (Serial ATA) インターフェースに接続されるハードドライブやSSDをサポートするドライバ群です。libataライブラリが中心となり、様々なSATAホストコントローラ(AHCI)に対応するための共通基盤を提供します。NCQ (Native Command Queuing) などの高度な機能もサポートし、ストレージ性能を最大限に引き出します。\n\nlibataは、SATAコントローラドライバ（低レベルなハードウェア操作）と、上位のブロックレイヤおよびSCSIサブシステムとの間の、翻訳レイヤとして機能します。SATAデバイスをSCSIデバイスのように見せることで、多くの既存のツールやインフラを再利用できるようにしています。NCQは、複数のI/Oリクエストをドライブ側で並べ替えて効率的に処理できるようにする機能で、ランダムアクセス性能を大幅に向上させます。'},
        { name: 'gpu/', summary: 'グラフィックスプロセッシングユニット（GPU）用ドライバ', description: 'NVIDIA, AMD, IntelなどのGPUを制御するための複雑なドライバ群です。現代のLinuxでは、Direct Rendering Manager (DRM) と Kernel Mode Setting (KMS) を中心としたフレームワークが提供されています。DRMは、複数のアプリケーションからのGPUリソースへのアクセスを調停し、KMSは起動プロセスの早い段階でグラフィックス表示の解像度やリフレッシュレートを設定します。これにより、ちらつきのないスムーズなブート画面を実現します。ドライバは、ユーザースペースのグラフィックスライブラリ(Mesaなど)に、ハードウェアアクセラレーションのためのAPIを提供します。\n\nDRM/KMSモデルは、かつてユーザースペースのXサーバが担っていたビデオモード設定の役割をカーネルに移管した点で画期的でした。これにより、グラフィカルなブート画面、仮想コンソール間のスムーズな切り替え、そしてWaylandのような新しいディスプレイサーバプロトコルの実現が可能になりました。ドライバは、GPUのコマンドスケジューラ、メモリマネージャ、ディスプレイコントローラといった複雑なコンポーネントを管理し、3Dレンダリングや動画デコードなどのタスクをハードウェアにオフロードします。' },
        { name: 'hid/', summary: 'ヒューマンインタフェースデバイス (HID)', description: 'USBやBluetoothで接続されるキーボード、マウス、ゲームコントローラ、タッチスクリーンなどのための汎用的なドライバフレームワークです。これらのデバイスは、自身の機能（ボタン、軸、LEDなど）を記述した「レポートディスクリプタ」を持っており、HIDサブシステムはこれを解釈して、標準的な入力イベント(`EV_KEY`, `EV_REL`, `EV_ABS`など)に変換します。これにより、デバイス固有のドライバを必要とせずに、多くの入力デバイスが「ただ挿すだけで」動作します。\n\nこのアーキテクチャの美しさは、デバイスの「何であるか」（マウス、キーボード）ではなく、デバイスが「何をするか」（相対座標の移動、キーコードの送信）に焦点を当てている点です。HIDサブシステムがレポートディスクリプタを解析し、その結果をinputサブシステムに渡すことで、ハードウェアの多様性を吸収します。これにより、メーカーはLinux用の特別なドライバを作成することなく、標準HID仕様に準拠するだけでデバイスをサポートさせることができます。' },
        { name: 'i2c/', summary: 'I2C通信バスのサポート', description: '2本の信号線（SDA, SCL）で多数のデバイスと通信できる低速なシリアルバス、I2C (Inter-Integrated Circuit) のサポートです。特に組み込みシステムで、温度センサー、EEPROM、リアルタイムクロック、タッチスクリーンコントローラなどの多数の周辺機器と通信するために広く利用されています。I2Cアダプタドライバと、その先に接続されるデバイスドライバの2層構造になっています。\n\nI2Cコアが、バス上のデバイスのアドレス指定や、スタート/ストップコンディションの生成といったプロトコルの詳細を抽象化します。I2Cアダプタドライバは、特定のCPUやチップセットが持つI2Cコントローラのレジスタを操作する方法を実装します。そして、個々のセンサーなどのデバイスドライバは、I2Cコアが提供する`i2c_transfer`のようなAPIを呼び出すだけで、物理的なバスの操作を意識することなく、デバイスとの間でデータの読み書きができます。' },
        { name: 'gpio/', summary: '汎用I/O (GPIO) サポート', description: 'CPUやチップセットが持つ、単純なデジタル入出力ピンである汎用I/O(GPIO)を制御するための統一されたフレームワークです。組み込みシステムやシングルボードコンピュータ(SBC)で、LEDの点灯・消灯、ボタンの入力検知、他のICの制御など、ハードウェアを直接操作するために不可欠です。`gpiod`ライブラリを通じてユーザースペースからも安全にアクセスできます。\n\nこのフレームワークは、GPIOピンを番号で直接指定する古い方法から、`"power-led"`のような機能名で記述的に要求する現代的な方法へと進化しました。デバイスツリー(Device Tree)と連携し、ボードの設計時に各GPIOピンの役割を定義しておくことで、ソフトウェアはハードウェアの具体的な配線を意識する必要がなくなり、移植性が向上します。また、入力ピンの割り込み生成機能もサポートしており、ボタンが押されたといったイベントを効率的に検知できます。' },
        { name: 'input/', summary: '入力デバイス（キーボード、マウスなど）用ドライバ', description: 'キーボード、マウス、タッチパッド、ジョイスティックなどの物理的な入力デバイスを管理するサブシステムです。ハードウェアからのイベント(キー押下、マウス移動など)を標準化されたイベントコードに変換し、`/dev/input/eventX`というデバイスファイル（`evdev`インターフェース）を通じてユーザースペースに通知します。これにより、アプリケーションはハードウェアの違いを意識することなく入力イベントを処理できます。\n\nこのサブシステムは、ハードウェアからの生データを抽象的なイベントに変換する役割を担います。例えば、キーボードドライバは、キーのスキャンコードを受け取り、それを`KEY_A`のような標準的なキーコードに変換します。タッチパッドドライバは、指の座標データを相対移動イベント(`REL_X`, `REL_Y`)や絶対座標イベント(`ABS_X`, `ABS_Y`)に変換します。この共通化された`evdev`インターフェースのおかげで、X.orgサーバやWaylandコンポジタ、あるいはゲームのようなアプリケーションは、多種多様な入力デバイスを統一的な方法で扱うことができます。' },
        { name: 'iommu/', summary: 'IOMMUサポート', description: 'I/Oメモリ管理ユニット(IOMMU)を制御するドライバです。IOMMUは、DMA(Direct Memory Access)を行うデバイスに対して、CPUのMMUと同様に、物理メモリを仮想化して見せるハードウェアです。これにより、デバイスがアクセスできるメモリ領域を制限し、不正なメモリアクセスを防ぐことでセキュリティを向上させます。また、仮想マシンに物理デバイスを直接割り当てるパススルー(Intel VT-d, AMD-Vi)を実現するためにも不可欠です。\n\nIOMMUがない場合、DMA可能なデバイスは物理メモリ全体にアクセスできてしまうため、悪意のある、またはバグのあるデバイスがカーネルメモリを破壊する危険性があります。IOMMUは、デバイスから見えるメモリアドレス（IOVA - I/O Virtual Address）と、実際の物理メモリアドレスとの間に、変換テーブルを設けます。ドライバは、DMAを行う際に、このIOMMU APIを通じてマッピングを作成し、デバイスにはIOVAを渡します。これにより、デバイスは許可されたメモリ領域にしかアクセスできなくなり、システム全体の堅牢性が向上します。' },
        { name: 'media/', summary: 'ビデオおよびオーディオキャプチャデバイス用ドライバ', description: 'Webカメラ、TVチューナー、ビデオキャプチャカード、ラジオ受信機などのマルチメディアデバイスをサポートします。Video4Linux2 (V4L2) フレームワークが中心となり、ビデオストリームのフォーマットネゴシエーション、バッファ管理、各種コントロール（明るさ、コントラストなど）のための統一されたAPIを提供します。\n\nV4L2は非常に多機能なフレームワークで、単純なビデオキャプチャだけでなく、ハードウェアによる動画のエンコード/デコード、映像処理機能などもサポートします。アプリケーションは`ioctl`システムコールを通じて、デバイスの能力を問い合わせたり、ビデオフォーマット（解像度、ピクセルフォーマットなど）を設定したり、DMA用のバッファを要求したりします。この共通フレームワークにより、GStreamerやFFmpegのようなマルチメディアアプリケーションが、多種多様なハードウェアを透過的に利用できます。' },
        { name: 'mtd/', summary: 'メモリ技術デバイス (MTD)', description: 'NANDやNORフラッシュメモリ、SPIフラッシュなど、一般的なブロックデバイスとは異なる特性（書き込み/消去の非対称性、消去ブロック単位の操作、不良ブロックの存在など）を持つソリッドステートストレージを扱うためのサブシステムです。ウェアレベリング（書き込みを平準化して寿命を延ばす技術）や不良ブロック管理を行うための抽象化レイヤ(UBI: Unsorted Block Images)を提供し、その上にJFFS2やUBIFSといったフラッシュメモリ専用のファイルシステムを構築します。\n\nNANDフラッシュは、書き込む前にブロック全体を消去する必要があり、また書き込み回数に上限があります。MTDサブシステムは、これらのハードウェアの癖を隠蔽します。UBIレイヤは、論理的なブロックを物理的なブロックに動的にマッピングすることで、特定のブロックに書き込みが集中しないようにし（ウェアレベリング）、ハードウェアが検出した不良ブロックを透過的に回避します。これにより、上位のファイルシステムは、信頼性の高いリニアなブロックデバイスとしてストレージを扱うことができます。' },
        { name: 'net/', summary: 'ネットワークインターフェースカード（NIC）用ドライバ', description: 'Ethernetカード、Wi-Fiアダプタ、InfiniBandアダプタなど、多種多様なネットワークデバイスを制御するドライバです。デバイスを初期化し、メモリ上に送受信用のリングバッファを構築し、ネットワークスタックとの間でパケット(`sk_buff`構造体)を送受信します。パフォーマンス向上のため、NAPI (New API) という技術を用いて、高負荷時には割り込みをポーリングに切り替えることで、割り込み処理のオーバーヘッドを削減します。\n\n従来のドライバはパケットを受信するたびにCPU割り込みを発生させていましたが、高速なネットワークではこれが毎秒数万回にもなり、CPUが割り込み処理だけで手一杯になってしまいました（ライブロック）。NAPIは、パケットが到着すると割り込みを一旦無効にし、代わりにポーリングモードに入ります。そして、受信キューにあるパケットをまとめて処理し、キューが空になったら再び割り込みを有効にします。この割り込みとポーリングの動的な切り替えにより、低負荷時の低レイテンシと高負荷時の高スループットを両立させています。' },
        { name: 'nvme/', summary: 'NVM Expressドライバ', description: 'PCI Expressバスに直接接続される超高速なソリッドステートドライブ(SSD)のための、NVM Expressプロトコルスタックとドライバです。従来のSATA/AHCIプロトコルがハードディスクを前提としていたのに対し、NVMeはフラッシュメモリの特性（高い並列性、低レイテンシ）を最大限に活かすよう設計されています。複数のI/Oキューをサポートし、CPUコアとキューを対応させることで、マルチコア環境でのスケーラビリティを劇的に向上させます。\n\nAHCIが単一のコマンドキューしか持たなかったのに対し、NVMeは最大65536個のI/Oキューを持つことができます。NVMeドライバは、`blk-mq`フレームワークと連携し、各CPUコアがロックなしで自身のキューにコマンドを投入できるようにします。これにより、コア数が増えてもI/O性能がリニアにスケールし、現代のメニーコアCPUと高速SSDの性能を最大限に引き出すことができます。これはストレージ技術における大きなパラダイムシフトです。' },
        { name: 'pci/', summary: 'PCIおよびPCIeバスのサポート', description: '現代のコンピュータの主要な拡張バスであるPCI (Peripheral Component Interconnect) および PCI Expressバスを管理するコアロジックです。システムの起動時にバスをスキャンして接続されているデバイスを列挙し、各デバイスのコンフィグレーション空間を読み取ります。そして、BAR (Base Address Register) を通じて、メモリアドレス空間やI/Oポート空間などのリソースを各デバイスに割り当て、デバイスドライバがデバイスと通信できるようにします。ホットプラグや電源管理の機能もサポートしています。\n\nこのサブシステムは、プラットフォーム（例: x86, ARM）に依存しない共通のPCI APIを他のドライバに提供します。デバイスの列挙は、バス番号、デバイス番号、ファンクション番号を順番にスキャンしていくことで行われます。デバイスが見つかると、そのベンダーIDとデバイスIDを読み取り、対応するドライバを検索します。また、PCIeで導入されたMSI/MSI-X（メッセージシグナル割り込み）のサポートもここで行われ、従来のピンベースの割り込みよりも効率的な割り込み処理を可能にします。' },
        { name: 'rtc/', summary: 'リアルタイムクロック (RTC)', description: 'システムの電源がオフの状態でも、バッテリーバックアップによって時刻を維持し続けるハードウェアであるリアルタイムクロック(RTC)用のドライバフレームワークです。カーネルは起動時にRTCから現在時刻を読み取り、システムクロックを初期化します。また、RTCが持つアラーム機能を利用して、指定した時刻にシステムをスリープ状態から復帰させる（ウェイクアップする）ことも可能です。\n\nRTCは単に時刻を維持するだけでなく、システムの高精度なタイムキーピングの基準点としても機能します。システムシャットダウン時には、カーネルは現在のシステム時刻をRTCに書き戻し、次回の起動に備えます。このフレームワークは、様々なメーカーのRTCチップの違いを吸収し、`/dev/rtc`という標準的なインターフェースをユーザースペースに提供します。' },
        { name: 'scsi/', summary: 'SCSIおよびSASストレージデバイス用ドライバ', description: '主にエンタープライズ向けの高性能ストレージシステムで使用される、SCSI (Small Computer System Interface) プロトコルスタックです。SAS (Serial Attached SCSI) やファイバーチャネル、iSCSIなどの様々なトランスポート層の上で動作します。コマンドキューイング(TCQ)やエラーリカバリなどの高度な機能をサポートし、高い信頼性とパフォーマンスが要求される環境で中心的な役割を果たします。\n\nSCSIアーキテクチャは、上位層（ブロックデバイスなど）、中間層（SCSIコア）、下位層（ホストバスアダプタドライバ）の3層構造になっています。SCSIコアがプロトコルの大部分を処理し、エラーハンドリングやタイムアウト処理、デバイスの再スキャンなどの共通機能を提供します。これにより、HBAドライバの開発者は、特定のハードウェアとの通信に集中できます。この堅牢な設計が、SCSIが長年にわたりエンタープライズストレージの標準であり続ける理由です。' },
        { name: 'spi/', summary: 'SPIバスのサポート', description: '組み込みシステムで広く使われる、高速な全二重同期シリアルバスであるSPI (Serial Peripheral Interface) のマスターコントローラドライバとプロトコル層をサポートします。1つのマスターと複数のスレーブデバイス（センサー、フラッシュメモリ、ディスプレイなど）が、4本の信号線（SCLK, MOSI, MISO, CS）で通信します。このディレクトリは、SPIコントローラの抽象化と、その先に接続されるSPIデバイスドライバのための共通フレームワークを提供します。\n\nSPIフレームワークは、SPIメッセージのキューイングや、コントローラドライバとデバイスドライバ間の調停を行います。デバイスドライバは、送信したいデータと受信したいデータのバッファを含む`spi_message`を作成し、フレームワークに送信を依頼します。フレームワークは、バスが利用可能になると、適切なチップセレクト(CS)信号をアクティブにし、SPIコントローラドライバを呼び出して実際のデータ転送を実行します。' },
        { name: 'usb/', summary: 'USBプロトコルスタックとデバイスドライバ', description: 'USB (Universal Serial Bus) ホストコントローラ(xHCI, EHCI, OHCI)のドライバと、それに接続される膨大な種類のUSBデバイス(ストレージ、キーボード、マウス、オーディオ、カメラ等)のためのドライバが含まれます。USBリクエストブロック(URB)と呼ばれる非同期なデータ構造を用いて、デバイスとのコントロール、バルク、インタラプト、アイソクロナスといった各種転送を管理します。USBハブを通じてツリー状に接続されたデバイスの検出と管理も行います。\n\nUSBコアは、デバイスの接続・切断を検出し、デバイスの列挙プロセスを管理します。列挙では、デバイスにアドレスを割り当て、その機能（デバイスクラス、ベンダーID、プロダクトIDなど）を記述したディスクリプタを読み取ります。そして、その情報に最もよく一致するUSBデバイスドライバをロードします。URBは、特定のUSBエンドポイントとのデータ転送要求をカプセル化したものであり、ドライバはURBをサブミットし、完了時にコールバックを受け取るという非同期モデルで動作します。' },
        { name: 'watchdog/', summary: 'ウォッチドッグタイマドライバ', description: 'システムが何らかの理由でフリーズ（ハングアップ）した場合に、自動的にリブートさせるためのウォッチドッグタイマハードウェア用のドライバです。カーネルやユーザースペースのデーモンが、定期的にタイマを「キック」（リセット）し続けます。もし一定時間キックがない場合、ハードウェアが強制的にシステムリセット信号を生成します。高可用性が求められる組み込みシステムやサーバーの信頼性を高めるために重要な機能です。\n\nウォッチドッグフレームワークは、`/dev/watchdog`という標準的なキャラクタデバイスインターフェースを提供します。ユーザースペースのウォッチドッグデーモンは、このデバイスファイルを開き、定期的に書き込み操作を行うことでタイマをキックします。もしデーモン自体がクラッシュしたり、システム全体のスケジューリングが停止したりして書き込みが途絶えると、ハードウェアタイマがタイムアウトし、システムを安全な状態（リブート）に戻します。' },
        { name: 'char/', summary: 'キャラクタデバイス用ドライバ', description: 'データをブロック単位ではなく、バイトストリームとして順次アクセスするキャラクタデバイスのドライバです。代表的なものに、シリアルポート(`ttyS`)、仮想コンソール(`tty`)、そしてユーザースペースとカーネル間の柔軟な通信路を提供する擬似端末(`pty`)などがあります。また、`/dev/random`や`/dev/null`のような仮想的なデバイスもキャラクタデバイスとして実装されています。\n\nキャラクタデバイスは、ファイルシステム上のノード（`mknod`で作成）にメジャー番号とマイナー番号で関連付けられます。メジャー番号はどのドライバが対応するかを示し、マイナー番号はそのドライバが管理する個々のデバイスを区別するために使われます。`open`, `read`, `write`, `ioctl`などのファイル操作がデバイスファイルに対して行われると、VFSはメジャー番号を基に対応するドライバの関数を呼び出します。',
          children: [
            { name: 'tty_io.c', summary: 'TTYサブシステムの中核', description: 'ターミナルデバイス（物理シリアルポート、USB-シリアル変換器、仮想コンソール、擬似端末など）を統一的に扱うためのサブシステムの中核です。ユーザからのキー入力をバッファリングし、行編集（バックスペースなど）を行い、アプリケーションに渡す「ラインディシプリン」という概念が特徴的です。シェルやターミナルエミュレータが動作するための基盤となっています。\n\nTTYサブシステムは、TTYドライバ（ハードウェアとの通信）、TTYコア（共通のデータフロー制御）、そしてラインディシプリンの3層構造になっています。ラインディシプリンは、TTYデバイスとユーザプロセスの間のデータ変換層として機能します。デフォルトの`N_TTY`ラインディシプリンは、`Ctrl-C`による割り込み信号の生成や、`stty`コマンドで設定可能な様々な端末セマンティクスを実装しています。この柔軟な構造が、UNIX系の対話的シェルの強力な機能を実現しています。' },
          ]
        },
        { name: 'staging/', summary: '開発中のドライバ', description: '品質がまだメインラインの厳しい基準に達していない、開発中または大規模なクリーンアップが必要なドライバやサブシステムのための一時的な置き場所です。カーネルコミュニティのレビューを受け、コーディングスタイルやAPIの利用法が改善され、品質が十分に向上したと判断されれば、`drivers/`以下の適切なサブディレクトリに「卒業」します。実験的な機能がここから始まることも多いです。\n\nこのディレクトリの存在は、Linuxカーネルの開発プロセスの柔軟性を示しています。完璧ではないコードでも、まずはツリーに取り込んで広くテストとレビューに晒し、コミュニティの協力によって品質を向上させていく、というインクリメンタルなアプローチを可能にします。ただし、ここにあるドライバはAPIが不安定であったり、バグを含んでいたりする可能性が高いため、本番環境での使用には注意が必要です。' },
      ],
    },
    {
      name: 'firmware/',
      summary: 'デバイスファームウェアバイナリ',
      description: '特定のハードウェアデバイスが動作するために必要なファームウェアの「バイナリブロブ」を格納するディレクトリです。これらのファイルはプロプライエタリなものが多く、ソースコードは公開されていません。カーネルのビルド時に、これらのファームウェアは`/lib/firmware`にインストールされ、対応するデバイスドライバが初期化される際に、`request_firmware()` APIを通じてカーネルに動的にロードされます。これにより、オープンソースのドライバが、クローズドソースのファームウェアを必要とするハードウェア（Wi-Fiカード、GPU、SNDチップなど）をサポートすることが可能になります。\n\nこの仕組みは、フリーソフトウェアの理念と、プロプライエタリなファームウェアを必要とするハードウェアをサポートするという現実的な要求との間の妥協点として生まれました。ドライバ自体はオープンソースであるため、誰でもレビューや修正が可能ですが、デバイス内部で動作するファームウェアはベンダーが提供するバイナリのままロードされます。`request_firmware()` APIは、ユーザースペースのエージェント（通常はudev）にファームウェアのロードを要求し、ユーザースペースがファイルシステムからファイルを見つけてカーネルに渡す、という柔軟な仕組みになっています。',
    },
    {
      name: 'fs/',
      summary: '仮想ファイルシステム（VFS）とファイルシステム',
      description: 'VFS (Virtual Filesystem Switch) は、ユーザースペースのアプリケーションに対して、`open()`, `read()`, `write()` といった標準的なPOSIX APIを通じて、統一されたファイルシステムインターフェースを提供する強力な抽象化レイヤです。システムコールはまずVFSによって受け取られ、VFSが具体的なファイルシステム(ext4, XFS, Btrfs, NFSなど)の適切な処理を動的に呼び出します。この「スイッチ」機能により、アプリケーションは背後にあるファイルシステムの種類や、それがローカルディスク上にあるかネットワーク越しにあるかを意識する必要がありません。このディレクトリには、VFSのコアロジックと、Linuxがサポートする多種多様なファイルシステムの実装が含まれています。\n\nVFSは主に4つの主要なオブジェクト（スーパーブロック、inode、dentry、file）で構成されます。スーパーブロックはマウントされたファイルシステム全体を表し、inodeは個々のファイルやディレクトリのメタデータを表します。dentry（ディレクトリ・エントリ）はファイル名とinodeを結びつける役割を持ち、パス名解決の高速化のためにキャッシュ（dcache）されます。fileオブジェクトは、プロセスがオープンしたファイルの状態（現在の読み書き位置など）を表します。これらのオブジェクトと、それらを操作する関数ポインタの集まり（`inode_operations`, `file_operations`など）が、VFSの抽象化の核心です。',
      children: [
        { name: 'ext4/', summary: 'ext4ファイルシステム', description: '多くのLinuxディストリビューションで長年にわたり標準ファイルシステムとして採用されてきた、非常に安定していて信頼性の高いジャーナリングファイルシステムです。ファイルデータを連続したブロック領域で管理する「エクステント」の導入により、従来のブロックマッピング方式に比べて大きなファイルの性能が向上しました。また、実際の書き込みを遅らせる「遅延アロケーション」により、より効率的なブロック割り当てを可能にし、断片化を抑制します。\n\nジャーナリングは、ファイルシステムのメタデータ（inodeやディレクトリブロックなど）への変更を、実際にディスクに書き込む前に、まずジャーナルと呼ばれる特別なログ領域に書き込むことで、クラッシュ時のファイルシステムの一貫性を保証する技術です。システムクラッシュ後、`fsck`はジャーナルを再生するだけで、ファイルシステムを迅速に整合性の取れた状態に復旧できます。ext4は、パフォーマンスと信頼性のバランスが取れた、実績のあるファイルシステムです。' },
        { name: 'btrfs/', summary: 'Btrfsコピーオンライトファイルシステム', description: 'スナップショット（特定の時点のファイルシステムの状態を瞬時に保存）、サブボリューム、透過的な圧縮、内蔵RAID機能など、多くの先進的な機能を備えた次世代のコピーオンライト(CoW)ファイルシステムです。データやメタデータを変更する際、既存のブロックを上書きせず、新しい場所に書き込んでからポインタを更新するため、書き込み中のクラッシュに対する耐障害性が非常に高いのが特徴です。\n\nCoWの設計は、Btrfsの多くの機能の基盤となっています。スナップショットは、ファイルシステムのルートを指すポインタをコピーするだけで、ほぼ瞬時に作成できます。以降の変更は新しいブロックに書き込まれるため、スナップショットは変更前の状態を保持し続けます。また、すべてのデータブロックとメタデータブロックのチェックサムを計算・保存し、読み込み時に検証することで、データの破損（ビット腐敗）を検出し、RAID構成の場合は自動的に修復することも可能です。' },
        { name: 'xfs/', summary: 'XFS高性能ファイルシステム', description: '元々はSGIによって開発された、大規模なファイルシステムや巨大なファイルに対して非常に高いパフォーマンスを発揮するよう設計された64ビットジャーナリングファイルシステムです。アロケーショングループという概念を用いて並列I/O性能を最大化する設計になっており、高性能コンピューティング(HPC)や大規模ストレージサーバーで広く採用されています。\n\nアロケーショングループは、ファイルシステム全体を複数の独立した領域に分割するものです。各アロケーショングループは自身のinodeと空き領域を持っており、複数のスレッドが異なるアロケーショングループに対して同時にブロックを割り当てることができます。これにより、メタデータ操作におけるロックの競合が大幅に減少し、マルチコアシステムでのスケーラビリティが向上します。また、遅延アロケーション技術も積極的に活用し、効率的なI/Oを実現します。' },
        { name: 'nfs/', summary: 'ネットワークファイルシステム（NFSクライアント）', description: 'ネットワーク越しにリモートのマシン上のファイルを、あたかもローカルのファイルであるかのようにアクセス可能にするNFS (Network File System) プロトコルのクライアント実装です。分散コンピューティング環境において、複数のサーバー間でファイルを共有するための中心的な役割を果たします。\n\nユーザがNFS上のファイルにアクセスすると、VFSはNFSクライアントの関数を呼び出します。NFSクライアントは、その操作をRPC (Remote Procedure Call) リクエストに変換し、ネットワーク経由でNFSサーバに送信します。サーバからの応答を受け取ると、その結果をVFSに返します。パフォーマンス向上のため、NFSクライアントはデータのキャッシュ（属性キャッシュ、ページキャッシュ）を積極的に行いますが、複数のクライアント間でのキャッシュの一貫性を維持するための複雑なメカニズムも備えています。' },
        { name: 'nfsd/', summary: 'ネットワークファイルシステム（NFSサーバー）', description: 'カーネル空間で動作する高性能なNFSサーバーの実装です。ユーザースペースで動作するNFSサーバーに比べて、データコピーやコンテキストスイッチのオーバーヘッドが少なく、より効率的なファイルサービスを提供できます。`knfsd`というカーネルスレッド群によって処理が実行されます。\n\nクライアントからのRPCリクエストは、カーネルのネットワークスタックによって受信され、`nfsd`スレッドに渡されます。`nfsd`はリクエストを解釈し、ローカルのファイルシステム（ext4など）をVFS経由で操作して、データの読み書きを行います。そして、結果をRPC応答としてクライアントに返します。すべての処理がカーネル空間で完結するため、ユーザ空間とカーネル空間の間のデータコピーが不要になり、特に大規模なデータ転送において高いパフォーマンスを発揮します。' },
        { name: 'cifs/', summary: 'CIFS/SMBファイルシステム', description: '主にWindowsネットワーク環境で標準的に使用されるSMB (Server Message Block) / CIFS (Common Internet File System) プロトコルのクライアント実装です。LinuxマシンからWindowsのファイルサーバーやSambaサーバーにシームレスにアクセスすることを可能にします。\n\nNFSと同様にVFSと連携して動作しますが、SMB/CIFSプロトコルはNFSよりもステートフルで複雑な面が多く、ファイルロックや認証メカニズム（NTLM, Kerberos）などもサポートする必要があります。このドライバは、これらのプロトコルの詳細をカプセル化し、Linuxユーザに透過的なファイルアクセスを提供します。' },
        { name: 'proc/', summary: '`/proc`仮想ファイルシステム', description: 'ディスク上には実体が存在しない、カーネルの内部データ構造や統計情報をファイルとして見せるための特殊な仮想ファイルシステムです。実行中のプロセスの情報 (`/proc/[PID]`)、CPU情報 (`/proc/cpuinfo`)、メモリ使用量 (`/proc/meminfo`) など、システムの現在の状態を動的に生成して提供します。デバッグやシステム監視に不可欠なインターフェースです。\n\n`/proc`内のファイルが読み書きされると、VFSはprocfsの実装を呼び出します。procfsは、特定のファイルに対応する関数を呼び出し、その関数がカーネルの内部変数を読み取って、その内容をテキスト形式でフォーマットしてユーザに返します。これにより、`ps`や`top`、`free`といった多くの標準的なシステム監視ツールが機能しています。これは、カーネルの状態をユーザ空間に公開するための、非常に強力で柔軟な仕組みです。' },
        { name: 'sysfs/', summary: '`/sys`仮想ファイルシステム', description: 'カーネルのデバイスモデル（バス、デバイス、ドライバの関係）を、階層的なディレクトリ構造としてユーザースペースに公開するための仮想ファイルシステムです。`udev`デーモンがこの情報を利用して、デバイスファイル(`/dev`)を動的に作成・管理したり、デバイスの接続・切断イベントに応じてスクリプトを実行したりします。デバイスの属性（例: 電源状態）を読み書きすることも可能です。\n\n`sysfs`のディレクトリ構造は、カーネル内部のkobject階層を直接反映したものです。各kobjectは`sysfs`内にディレクトリとして表現され、その属性（attribute）がファイルとして現れます。これらのファイルを読み書きすることで、ユーザ空間からカーネルオブジェクトの状態を監視したり、制御したりできます。例えば、LEDの明るさを変更したり、ディスクのI/Oスケジューラを変更したりといった操作が、ファイルの書き込みとして行えます。' },
        { name: 'super.c', summary: 'スーパーブロック管理', description: 'マウントされたファイルシステムのインスタンス全体に関する情報（ファイルシステムの種類、ブロックサイズ、inodeの数、空きブロック数など）を保持する`super_block`オブジェクトを管理するコードです。ファイルシステムがマウントされると、VFSは具体的なファイルシステムからスーパーブロック情報を読み取り、メモリ上に`super_block`オブジェクトを作成します。システム上のすべてのファイルシステム操作は、このスーパーブロックを経由して行われます。\n\nこのファイルには、スーパーブロックの割り当て、初期化、破棄を行う関数が含まれています。また、マウントされたファイルシステムのリストを管理し、ファイルシステムの同期（`sync()`システムコール）やアンマウント処理の中心的なロジックも担っています。スーパーブロックは、特定のファイルシステムへのすべてのアクセスの起点となる、VFSの根幹をなすオブジェクトです。' },
        { name: 'namei.c', summary: 'パス名解決', description: 'VFSの中核機能の一つであり、`/home/user/file.txt`のようなファイルパス文字列を、対応する`dentry`（ディレクトリ・エントリ）と`inode`（インデックス・ノード）に解決する処理（パスウォーク）を実装しています。ルートディレクトリから始まり、パスを構成要素（`home`, `user`, `file.txt`）に分割し、各ディレクトリの`inode`を辿りながら、パーミッションチェックを行い、最終的なターゲットを見つけ出します。\n\nこの処理はすべてのファイルアクセスで行われるため、その性能はシステム全体に大きな影響を与えます。dentryキャッシュ(dcache)は、このパス解決を高速化するために不可欠です。一度解決されたパスの構成要素（"home"など）とそのinodeの対応はdcacheに保存され、次回のアクセスではディスクを読まずにキャッシュから解決できます。このファイルは、そのdcacheの検索、およびキャッシュにない場合のディレクトリの読み込みといった複雑なロジックを実装しています。' },
        { name: 'inode.c', summary: 'inode管理', description: 'ファイルやディレクトリのメタデータ（所有者、グループ、パーミッション、タイムスタンプ、ファイルサイズ、データブロックへのポインタなど）を保持する`inode`オブジェクトの生成、破棄、およびキャッシュ管理を行います。inodeは特定のファイルシステムに属しており、VFS inodeは具体的なファイルシステムのinodeを包含する形で存在します。アクティブなinodeはメモリ上のinodeキャッシュに保持され、高速なアクセスを可能にします。\n\ninodeは、ファイル名とは独立してファイルを一意に識別します。これにより、一つのファイルが複数の名前（ハードリンク）を持つことが可能になります。このファイルに含まれるコードは、inodeの割り当てと解放、inodeキャッシュの管理（使用されなくなったinodeの回収など）、そしてダーティな（変更された）inodeをディスクに書き戻す処理などを担当します。inodeはファイルシステムの心臓部であり、その効率的な管理は不可欠です。' },
        { name: 'dcache.c', summary: 'dentryキャッシュ管理', description: 'ディレクトリ・エントリ・キャッシュ（dentry cacheまたはdcache）を管理するコードです。dcacheは、パス名解決（namei）のパフォーマンスを劇的に向上させるため、ファイル名とそれに対応するinodeの対応関係をメモリ上にキャッシュする仕組みです。一度解決したパスへの再アクセスは、ディスクにアクセスすることなくdcacheの検索だけで完了することが多いため、システム全体の性能に大きく貢献します。\n\ndcacheは、存在しないファイルへのアクセス（ネガティブdentry）もキャッシュします。これにより、アプリケーションが特定のファイルを何度も探しに行くような場合に、その都度ディスクアクセスが発生するのを防ぎます。dcacheは、LRU (Least Recently Used) に基づいて、メモリが不足すると古いエントリから破棄されます。このファイルのコードは、ハッシュテーブルを用いたdentryの高速な検索、およびキャッシュ全体の効率的な管理を担当します。' },
        { name: 'open.c', summary: 'ファイルオープン処理', description: '`open()`や`creat()`システムコールの中核的なロジックを実装しています。まずパス名解決(namei)を行い、ターゲットの`dentry`と`inode`を見つけます。次に、要求されたアクセスモード（読み込み、書き込みなど）に基づいてパーミッションをチェックします。成功すれば、プロセスに新しいファイルディスクリプタを割り当て、オープンされたファイルの状態を表現する`file`構造体を初期化し、それをファイルディスクリプタテーブルに関連付けます。\n\n`file`構造体は、同じファイルを複数のプロセスが開いている場合でも、プロセスごとに独立して存在します。これには、現在のファイルの読み書き位置（オフセット）や、オープン時に指定されたフラグ（`O_APPEND`など）が格納されます。一方、`inode`はファイルそのものを表し、すべてのプロセスで共有されます。この`file`と`inode`の分離が、UNIX系OSのファイルI/Oの柔軟性の鍵です。' },
        { name: 'exec.c', summary: 'プログラム実行', description: '`execve()`システムコールの実装です。これは、新しいプログラムを実行するための心臓部です。指定された実行可能ファイルを読み込み、そのヘッダ（通常はELFフォーマット）を解釈します。そして、現在のプロセスのメモリ空間（テキスト、データ、スタックセグメント）を破棄し、新しいプログラムのイメージで完全に置き換えます。バイナリフォーマットローダーを呼び出し、最終的に新しいプログラムのエントリポイントにジャンプすることで実行を開始します。\n\n`execve()`はプロセスID(PID)を変更しないという特徴があります。つまり、プロセスは「変身」するのであって、新しいプロセスが作られるわけではありません。この処理は、新しいメモリ空間の設定、引数と環境変数の新しいスタックへのコピー、そして最終的にユーザ空間の新しいエントリポイントへの復帰という、非常に複雑な手順を踏みます。`binfmt_elf.c`のようなバイナリフォーマットハンドラが、具体的なファイル形式の解釈を担当します。' },
        { name: 'pipe.c', summary: 'パイプとFIFOの実装', description: 'シェルで多用される`|`（パイプ）や、`mkfifo`で作成される名前付きパイプ（FIFO）のメカニズムを実装しています。パイプは、あるプロセスの標準出力を別のプロセスの標準入力に直接つなぐための、カーネルメモリ上のリングバッファとして機能します。ディスクI/Oを介さずにプロセス間でデータをストリーミングするための、古典的かつ効率的なIPCメカニズムです。このファイルは、パイプ用のファイル操作(`pipe_fops`)、inode操作、およびデータの読み書きロジックを管理します。\n\nパイプへの書き込みは、バッファに空きができるまでプロセスをブロック（スリープ）させ、読み込みは、バッファにデータが書き込まれるまでプロセスをブロックさせます。この生産者-消費者モデルの同期は、待機キュー(wait queue)を用いて効率的に実装されています。パイプのバッファサイズは固定ですが、近年のカーネルでは`fcntl()`でサイズを動的に変更することも可能です。' },
        { name: 'fcntl.c', summary: '`fcntl`と`ioctl`システムコール', description: '`fcntl()`システムコールの中心的な実装が含まれています。この多目的システムコールは、オープンされたファイルディスクリプタに対して、様々な制御操作（ディスクリプタの複製、ロックの取得・解放、非ブロッキングI/Oフラグの設定など）を行うために使用されます。また、ファイルシステムやデバイスドライバ固有の`ioctl()`操作のディスパッチ処理の一部も担当し、ユーザースペースとカーネル間の柔軟な制御チャネルを提供します。\n\n`fcntl()`の強力な機能の一つに、ファイルロック（アドバイザリロックと強制ロック）があります。これにより、複数のプロセスが同じファイルに同時に書き込むことによるデータ破損を防ぐことができます。`ioctl()`は、`fcntl()`よりもさらに汎用的で、デバイス固有の操作（例：シリアルポートのボーレート設定、端末ウィンドウサイズの変更など）を可能にするための「何でもあり」のシステムコールとして機能します。' },
        { name: 'epoll.c', summary: '`epoll` I/Oイベント通知機構', description: '大量のファイルディスクリプタを効率的に監視するための、高性能なI/Oイベント通知機構である`epoll`の実装です。`select()`や`poll()`が監視対象の全ディスクリプタを毎回スキャンする必要があるのに対し、epollは「準備ができた」ディスクリプタのリストをカーネルが能動的に維持するため、監視対象の数が増えてもパフォーマンスが低下しません（O(1)スケーラビリティ）。高性能なネットワークサーバーなど、多数の同時接続を扱うアプリケーションの根幹を支える技術です。\n\nepollの効率性の秘密は、2つのメカニズムにあります。一つは、監視対象のリストをカーネル内に永続的に保持し、`epoll_ctl()`で差分更新できる点です。もう一つは、ファイルディスクリプタがI/O可能になると、そのファイルに関連付けられた待機キューを通じてepollオブジェクトに通知が行われ、epollオブジェクトの「準備完了リスト」に追加される、コールバックベースの仕組みです。これにより、`epoll_wait()`は単に準備完了リストをユーザ空間にコピーするだけで済み、監視対象の数に依存しない高速な動作が可能になります。' },
      ],
    },
    {
      name: 'include/',
      summary: 'カーネルヘッダファイル',
      description: 'カーネル全体のソースコードからインクルードされるヘッダファイル(.h)が格納されています。ここには、カーネル内で使用される主要なデータ構造の定義（例: `task_struct`, `inode`）、関数プロトタイプ、グローバル変数、マクロ、定数などが含まれており、カーネルのコンパイルに不可欠です。APIは内部用とユーザースペース用で明確に分離されています。\n\nこのディレクトリ構造は、カーネルのモジュール性と抽象化を反映しています。各サブシステムは自身の公開APIを`include/linux/`以下のヘッダファイルで提供し、他のサブシステムはこれらのヘッダをインクルードすることで、実装の詳細を意識することなく機能を利用できます。この明確なインターフェース定義が、巨大なコードベースの管理を可能にしています。',
      children: [
        { name: 'linux/', summary: '内部カーネルAPIヘッダ', description: 'カーネルのサブシステム間で共有される、内部用のヘッダファイル群です。`sched.h` (スケジューラ)、`fs.h` (VFS)、`mm.h` (メモリ管理)、`skbuff.h` (ネットワーク)など、各サブシステムの重要なデータ構造やAPIが定義されています。これらのAPIはカーネルの内部実装に属するため、安定性は保証されず、カーネルのバージョンアップで変更される可能性があります。モジュールドライバ開発者が主に利用します。\n\n例えば、`linux/sched.h`には、プロセスを表す中心的なデータ構造である`task_struct`の完全な定義が含まれています。この構造体は数百のフィールドを持ち、プロセスの状態、スケジューリング情報、メモリ空間、開いているファイル、シグナルハンドラなど、プロセスに関するあらゆる情報を保持しています。カーネルの大部分のコードが、この構造体を直接的または間接的に参照します。' },
        { name: 'uapi/', summary: 'ユーザースペースAPI（UAPI）ヘッダ', description: 'User-space APIの略で、ユーザースペースのアプリケーションがカーネルと通信（主にシステムコールや`ioctl`を通じて）するために使用する、安定したABI(Application Binary Interface)を定義するヘッダファイル群です。ここに含まれる構造体や定数の定義は、一度公開されると後方互換性を維持するために慎重に管理されます。これにより、古いアプリケーションが新しいカーネル上でも正しく動作することが保証されます。\n\nこのディレクトリのヘッダは、カーネルをビルドする際にシステムヘッダ（`/usr/include/linux`など）としてインストールされ、glibcのようなCライブラリやアプリケーションから直接インクルードされます。UAPIの安定性を維持することは、Linuxエコシステム全体にとって極めて重要であり、ここの変更には厳格なレビュープロセスが課せられます。' },
        { name: 'asm-generic/', summary: '汎用アセンブリヘッダ', description: '特定のCPUアーキテクチャに依存しない、低レベル操作のための汎用的なヘッダファイルです。例えば、`ioctl`コマンド番号のエンコーディング方法や、アトミック操作のデフォルト実装などが提供されます。各アーキテクチャは、自身に最適化された実装を提供できる場合はそちらを優先し、そうでなければこの汎用実装を利用することで、コードの重複を減らし、移植性を高めています。\n\n多くのアーキテクチャで共通して使える低レベルな機能の実装をここに集約することで、新しいアーキテクチャへの移植作業が大幅に簡素化されます。移植担当者は、まず`asm-generic`の実装を利用してシステムを起動させ、その後、パフォーマンスが重要な部分から順に、アーキテクチャ固有の最適化された実装に置き換えていくことができます。' },
      ]
    },
    {
      name: 'init/',
      summary: 'カーネルの起動と初期化',
      description: 'カーネルの初期化プロセスの中心となるコードが含まれています。`main.c`内に定義されている`start_kernel()`関数は、アーキテクチャ固有の低レベルな初期設定が終わった後に呼び出される、実質的なカーネルの`main`関数です。この関数から、トラップの初期化、メモリ管理サブシステムの起動、スケジューラの初期化、VFSの初期化など、すべての主要なカーネルサブシステムが順次初期化されます。最終的に、最初のユーザースペースプロセスである`init`プロセス（PID 1）を起動し、システムの制御をユーザースペースに移します。\n\n`start_kernel()`は巨大で、何百もの初期化関数を順番に呼び出していきます。この過程で、`printk()`が利用可能になり、コンソールにカーネルの起動メッセージが出力され始めます。また、`initcall`というメカニズムが重要です。カーネルにリンクされた各モジュールは、自身の初期化関数を特定のレベル（`early_initcall`, `subsys_initcall`, `module_initcall`など）で登録しておくことができます。`start_kernel()`の後半で、これらの`initcall`がレベル順に実行され、コンパイル時に組み込まれた全てのドライバやサブシステムが初期化されます。この仕組みにより、カーネル本体のコードを変更することなく、新しい機能を簡単に追加できるようになっています。',
    },
    {
      name: 'ipc/',
      summary: 'プロセス間通信（IPC）',
      description: '同じシステム上で動作する複数のプロセスが、互いにデータを交換したり、動作を同期させたりするために必要な通信メカニズムを実装しています。古典的なSystem V IPC (メッセージキュー、セマフォ、共有メモリ) や、より現代的で堅牢なPOSIX準拠のメッセージキュー、セマフォなどが含まれます。ソケットやパイプも広義のIPCですが、それらは主に`net/`や`fs/`のディレクトリで実装されています。\n\nSystem V IPCは、キー（数値）を使ってIPCオブジェクトを識別する独自のネームスペースを持ち、古くから使われてきましたが、リソースリークが起きやすいなどの問題がありました。一方、POSIX IPCは、ファイルシステム上のパス名でオブジェクトを識別したり（名前付きセマフォ）、ファイルディスクリプタとして扱えたりするため（タイマー、イベント通知）、他のI/Oメカニズムと統一的に扱うことができ、より現代的なアプリケーションに適しています。このディレクトリは、これらの異なるセマンティクスを持つIPCメカニズムをカーネル内で提供します。',
    },
    {
      name: 'kernel/',
      summary: 'コアカーネルサブシステム',
      description: '特定のハードウェアアーキテクチャに依存しない、オペレーティングシステムの中核をなす基本的な機能群が実装されています。プロセスの生成・スケジューリング、同期プリミティブ(ロック、セマフォ)、時間管理とタイマー、シグナル処理、電源管理、カーネルのトレーシング機構など、カーネルの心臓部と言える極めて重要なコードが集まっています。\n\nこれらのサブシステムは、カーネルの他の全ての部分の基盤となります。例えば、`locking/`で提供されるミューテックスやスピンロックは、デバイスドライバからファイルシステム、ネットワークスタックに至るまで、カーネル内のあらゆる場所で共有データ構造を保護するために使用されます。`time/`サブシステムが提供するタイマー機能は、ネットワークのタイムアウト処理や、スケジューラの時間計測など、無数の場面で必要とされます。このディレクトリのコードの品質と効率が、システム全体の安定性と性能を決定づけます。',
      children: [
        { name: 'sched/', summary: 'プロセススケジューラ', description: 'CPU時間をどのプロセス（またはスレッド）に割り当てるかを決定する、OSの性能を左右する重要なコンポーネントです。Linuxでは、通常のプロセス向けにCFS (Completely Fair Scheduler)が採用されています。CFSは「仮想実行時間(vruntime)」という概念を用い、常にvruntimeが最も小さいプロセスを選択することで、全プロセスに公平なCPU時間を提供しようとします。実行可能プロセスは、vruntimeをキーとして赤黒木(red-black tree)で効率的に管理されます。リアルタイムプロセス向けには、FIFOやRound Robinといった別のスケジューリングポリシーが提供されます。\n\n各プロセスは、実行されるとその実行時間に優先度に応じた重み付けをした値が`vruntime`に加算されます。CPUを長く使ったプロセスほど`vruntime`が大きくなります。スケジューラは、次に実行するプロセスを選ぶ際、赤黒木の最も左のノード（`vruntime`が最小のノード）を常に選択します。これにより、今まであまり実行されていないプロセスが自然と選ばれることになり、「完全な公平性」が実現されます。赤黒木は、ノードの検索、挿入、削除がすべて対数時間(`O(log N)`)で行えるため、多数の実行可能プロセスが存在する場合でも効率的にスケジューリングできます。',
          children: [
            { name: 'core.c', summary: 'スケジューラのコアロジック', description: 'プロセススケジューラ全体の中心となる共通ロジックとデータ構造を実装しています。`schedule()`関数（明示的なスケジューリングの起点）、`try_to_wake_up()`関数（プロセスを起床させる）、プロセス優先度の管理、CPU間の負荷分散（ロードバランシング）のトリガー、スケジューリングドメインの構築など、特定のスケジューリングクラス（CFS, RTなど）に依存しない、スケジューラ全体の骨格を定義します。\n\n`schedule()`関数は、プロセスがI/O待ちなどでスリープする際や、タイムスライスを使い切った際に呼び出されます。この関数は、現在のCPUのランキュー（実行可能プロセスのリスト）から、次に実行すべきプロセスをスケジューリングクラスに問い合わせて選び出し、`context_switch()`を呼び出して実際のプロセス切り替えを行います。ロードバランシングは、定期的に、またはCPUがアイドルになった際にトリガーされ、ビジーなCPUからアイドルなCPUへプロセスを移動させることで、システム全体のスループットを向上させます。' },
            { name: 'fair.c', summary: 'CFS (Completely Fair Scheduler) の実装', description: 'LinuxのデフォルトスケジューラであるCFSの中核実装です。仮想実行時間（vruntime）という概念を用いて、CPU時間をプロセスに公平に分配することを目指します。実行可能なプロセスは、vruntimeをキーとする赤黒木(`cfs_rq`)に格納され、スケジューラは常に木の最も左側にあるノード（vruntimeが最小のプロセス）を選択して実行します。このファイルには、vruntimeの更新、プロセスのエンキュー・デキュー、そしてグループスケジューリング（cgroupsによるCPU帯域制御）のロジックが含まれています。\n\nvruntimeは64ビット変数であり、決して減少しません。これにより、ラップアラウンドの問題を回避しています。プロセスがスリープから起床する際には、その`vruntime`が他の実行中のプロセスから大きく遅れすぎないように調整されます。これにより、I/Oバウンドな対話的プロセスが、CPUバウンドなバッチプロセスによって長期間待たされる（飢餓状態になる）のを防ぎ、良好な応答性を維持します。' },
            { name: 'rt.c', summary: 'リアルタイムスケジューラの実装', description: '`SCHED_FIFO`（先入れ先出し）と`SCHED_RR`（ラウンドロビン）という、リアルタイムプロセス向けのスケジューリングポリシーを実装しています。これらのポリシーは、CFSよりも厳格な優先度ベースで動作し、最も優先度の高いリアルタイムプロセスが常に実行されることを保証します。優先度ごとに実行キュー（ランキュー）を持ち、システムの応答時間（レイテンシ）を重視するリアルタイムシステムや低遅延アプリケーションで不可欠な機能です。\n\n`SCHED_FIFO`は、より高い優先度のプロセスが現れるか、自らブロックするまで実行を続けます。同じ優先度のプロセスが複数ある場合は、先に実行可能になったプロセスが先に実行されます。`SCHED_RR`は`SCHED_FIFO`に似ていますが、各プロセスが一定のタイムスライスを使い切ると、同じ優先度の実行キューの末尾に移動させられる点が異なります。これにより、同じ優先度のプロセス間でCPU時間が公平に分配されます。これらのスケジューラは、通常のプロセスを無期限に待たせる可能性があるため、使用には注意が必要です。' },
          ]
        },
        { name: 'locking/', summary: 'ロックプリミティブ', description: 'マルチプロセッサ・マルチコア環境で、共有データへの同時アクセスによって発生する競合状態(race condition)を防ぐための、基本的な同期メカニズムです。短時間だけロックを保持する際に使われ、割り込みコンテキストでも使用可能な「スピンロック」、ロックが取得できない場合にプロセスをスリープさせる「ミューテックス」や「セマフォ」、読み込みアクセスは複数許可し、書き込みアクセスは一つだけ許可する「RWセマフォ」などが提供されています。\n\nスピンロックは、ロックが取得できない場合にCPUをビジーウェイト（ループを回して待機）させるため、ロックの保持時間が非常に短いことが想定される場面でのみ使用されます。一方、ミューテックスは、待機中にプロセスをスリープさせてCPUを他のプロセスに明け渡すため、ロックの保持時間が長くなる可能性がある場合に使用されます。割り込みハンドラのようなスリープできないコンテキストではスピンロックしか使えません。これらの同期プリミティブを適切に使い分けることが、性能と正当性を両立させる鍵です。' },
        { name: 'rcu/', summary: 'Read-Copy-Update (RCU)', description: '読み込みが非常に頻繁で、書き込みが比較的少ないデータ構造のための、高度でロックフリーな同期メカニズムです。読み込み側は、何のロックも取得せずにデータにアクセスできます。書き込み側は、まずデータのコピーを作成して変更し、その後ポインタをアトミックに更新して新しいデータを公開します。古いデータは、そのデータへの参照を持つ可能性のある全てのCPUが、参照を終えた「猶予期間(Grace Period)」が過ぎるのを待ってから安全に解放されます。これにより、読み込み側の性能を全く阻害することなくデータを更新でき、ネットワークルーティングテーブルなどで多用されます。\n\nRCUの読み込み側クリティカルセクションは`rcu_read_lock()`と`rcu_read_unlock()`で囲まれますが、これらは実際にはロックを取得せず、単にプリエンプション（コンテキストスイッチ）を禁止するだけです。猶予期間は、システム上の全てのCPUが少なくとも一度はコンテキストスイッチを経験した時点で終了します。なぜなら、コンテキストスイッチが発生すれば、そのCPUは古いデータへの参照を確実に失っているからです。この巧妙な仕組みにより、読み込み側のオーバーヘッドをほぼゼロにできるため、読み込み性能が極めて重要な場面で絶大な効果を発揮します。' },
        { name: 'time/', summary: '時間管理とタイマー', description: 'システムの時間を管理し、指定した時間後に関数を実行するためのタイマー機能を提供します。ハードウェアのタイマー割り込みを基に、システム全体の時刻を維持し、`jiffies`と呼ばれる内部的な時刻単位を更新します。高分解能タイマー(hrtimers)により、ナノ秒単位の精度でのタイマー設定が可能です。タイマーはタイマーホイールという効率的なデータ構造で管理され、多数のタイマーを効率的に処理できます。\n\n`jiffies`は、システム起動からのタイマー割り込みの回数を数えるカウンターで、伝統的にカーネルのタイムキーピングの基本単位でした。しかし、その分解能はタイマー割り込みの頻度（HZ）に依存し、比較的粗いものでした。`hrtimers`は、ハードウェアが提供する高精度なタイマーを利用し、タイマーイベントをより正確な時間に発行できるようにします。これにより、マルチメディアアプリケーションやリアルタイムシステムで要求される、より厳密なタイミング制御が可能になります。' },
        { name: 'power/', summary: '電源管理フレームワーク', description: 'システムの消費電力を管理し、バッテリー寿命を延ばすためのフレームワークです。システム全体を低電力状態にするサスペンド(RAMへの待避)やハイバネーション(ディスクへの待避)、CPUの負荷に応じて動作周波数や電圧を動的に変更するCPUFreq、そして個々のデバイスをアイドル時に低電力状態にするランタイム電源管理(Runtime PM)などが含まれます。\n\nランタイム電源管理は、デバイスが使用されていない短い時間でも積極的に低電力状態に遷移させることで、消費電力をきめ細かく削減する仕組みです。デバイスドライバは、デバイスがアイドル状態になったことをフレームワークに通知し、フレームワークがデバイスをサスペンドさせます。再びデバイスへのアクセスが必要になると、フレームワークが自動的にデバイスを復帰（レジューム）させます。これにより、システム全体がアクティブな状態であっても、個々のデバイスレベルで効率的な電力管理が可能になります。' },
        { name: 'bpf/', summary: 'eBPF（拡張バークレーパケットフィルタ）', description: 'カーネル内で、安全性が検証されたサンドボックス化されたカスタムプログラムを実行するための、非常に強力で高機能な仮想マシンです。eBPFプログラムは、カーネルにロードされる前に「ベリファイア」によって厳格な安全性チェック（無限ループの不存在、不正メモリアクセスの防止など）を受けます。その後、JITコンパイラによってネイティブな機械語に変換されるため、極めて高速に実行されます。ネットワーキング(XDP, TC)、トレーシング(kprobes, tracepoints)、セキュリティ監視など、カーネルを再コンパイルすることなく動的に機能を拡張するための革命的な技術として、現代のLinuxで広く利用されています。\n\nベリファイアはeBPFの安全性の中核です。プログラムのすべての可能な実行パスを静的に解析し、カーネルをクラッシュさせたり、セキュリティを侵害したりする可能性のある操作（NULLポインタの参照、境界外アクセス、無限ループなど）をコンパイル時に完全に排除します。この厳格な事前検証があるからこそ、ユーザが提供したコードをカーネル空間で安全に実行できるのです。eBPFは、ヘルパー関数を通じて限定されたカーネル機能にアクセスしたり、マップと呼ばれるキーバリュー型のデータ構造を使ってユーザ空間と情報をやり取りしたりすることもできます。' },
        { name: 'trace/', summary: 'トレースとプロファイリング', description: 'カーネルやアプリケーションの動作を詳細に分析し、パフォーマンスのボトルネックを特定したり、問題をデバッグしたりするための強力なインフラです。`ftrace`によるカーネル関数のトレース、ソースコードに静的に埋め込まれた`tracepoint`、カーネルの任意の命令を動的に書き換えてフックする`kprobes`などの機能を提供します。`perf`や`bpftrace`といったユーザースペースの高度なツールは、これらのカーネル機能を利用して動作します。\n\n`kprobes`は特に強力で、カーネルのほぼ任意の関数の入り口（kprobe）や出口（kretprobe）にプローブを動的に挿入できます。プローブがヒットすると、登録されたハンドラ関数が実行され、その時点でのレジスタの値や関数の引数などを記録できます。これにより、カーネルの動作を再コンパイルすることなく、非常に詳細に調査することが可能です。eBPFと組み合わせることで、プローブから収集したデータをカーネル内で集計・分析し、必要な情報だけをユーザ空間に送るといった、さらに高度なトレーシングが実現できます。' },
        { name: 'cgroup/', summary: 'コントロールグループ (cgroups)', description: 'プロセスのグループに対して、CPU時間、メモリ量、ディスクI/O帯域などのシステムリソースを制限、計測、分離するための機構です。ツリー状の階層構造を持ち、各ノードで異なるリソースの制限を設定できます。コンテナ技術(Docker, Kubernetes, LXC)の根幹をなす重要な機能であり、一つのシステム上で複数のアプリケーションやテナントを互いに影響を与えずに実行させる、リソース管理とマルチテナント環境の実現に不可欠です。\n\ncgroupsは、複数の「コントローラ」（CPUコントローラ、メモリコントローラなど）から構成されます。各コントローラは特定のリソースを管理します。例えば、CPUコントローラはCPU時間の割り当て（上限設定や相対的な重み付け）を行い、メモリコントローラはグループが使用できるメモリ量の上限を設定したり、メモリ不足時にどのグループからメモリを回収するかを決定したりします。この柔軟なリソース管理機構が、コンテナがホストOSのリソースを使い尽くすのを防ぎ、安定した共有環境を提供するための鍵です。' },
        { name: 'events/', summary: 'パフォーマンスイベント', description: '`perf`ツールが利用する、カーネル内のパフォーマンスイベントサブシステムです。CPUのパフォーマンスカウンタ（PMU）を抽象化し、CPUサイクル、命令実行数、キャッシュミスなどのハードウェアイベントや、コンテキストスイッチ、ページフォールトなどのソフトウェアイベントを計測するための統一されたインターフェースを提供します。\n\nこのサブシステムにより、アプリケーションやカーネルの特定の部分が、どれだけのCPUサイクルを消費したか、どれだけのキャッシュミスを発生させたか、といった非常に低レベルなパフォーマンスデータを収集できます。`perf record`コマンドは、これらのイベントをサンプリングし、`perf report`コマンドがその結果を分析して、プログラムのどこが「ホットスポット」（最も時間を消費している場所）であるかを特定するのに役立ちます。' },
        { name: 'irq/', summary: '割り込みリクエスト管理', description: 'ハードウェアデバイスからの割り込み要求（IRQ）を管理する中核サブシステムです。割り込みコントローラを抽象化し、IRQ番号とデバイスドライバの割り込みハンドラを関連付けます。割り込みの上半身（高速に処理すべき部分）と下半身（遅延可能な重い処理、softirq/tasklet/workqueue）への分割をサポートし、システムの応答性を維持します。\n\n割り込みハンドラは、他の割り込みを禁止した状態で実行されるため、その処理は可能な限り短くする必要があります。これを実現するため、処理は「上半身(top half)」と「下半身(bottom half)」に分割されます。上半身は、割り込みハンドラ本体であり、デバイスを静かにさせ、緊急のデータを読み取るなど、最小限の処理だけを行います。そして、より時間のかかる処理（例：ネットワークパケットの処理）を、後で実行するように下半身としてスケジュールします。この分割により、システムが長期間割り込みを禁止状態にすることを防ぎ、応答性を保ちます。' },
        { name: 'fork.c', summary: 'プロセス生成', description: '`fork()`、`vfork()`、`clone()`といった、新しいプロセスやスレッドを生成するためのシステムコールの中心的な実装です。新しいプロセス制御ブロック(`task_struct`)を作成し、親プロセスのコンテキスト（メモリ空間、ファイルディスクリプタ、シグナルハンドラなど）を複製または共有します。メモリ空間の複製は、実際に書き込みが発生するまで物理ページを親子で共有するコピーオンライト(Copy-on-Write, CoW)という技術によって、非常に効率的に行われます。\n\n`fork()`を呼び出すと、親プロセスのページテーブルが子プロセスにコピーされますが、ページテーブルエントリは両方とも同じ物理ページを指したまま、書き込み禁止に設定されます。親子どちらかのプロセスがそのページに書き込もうとすると、CPUがページフォールト例外を発生させます。カーネルの例外ハンドラがこれを捕捉し、その時点で初めて物理ページをコピーし、書き込みを行ったプロセスに新しいページの所有権を与えます。これにより、`fork()`直後に`execve()`を呼び出すような一般的なケースで、無駄なメモリコピーを完全に避けることができます。' },
        { name: 'signal.c', summary: 'シグナル処理', description: 'あるプロセスから別のプロセスへ非同期なイベントを通知するメカニズムである「シグナル」の送受信とハンドリングを管理します。シグナルマスクの管理、保留中のシグナル（ペンディングシグナル）の処理、ユーザースペースで登録されたシグナルハンドラを実行するためのスタックフレームの構築など、複雑なロジックを扱います。\n\nプロセスがカーネルモードからユーザモードに戻る直前、カーネルは保留中のシグナルがないかチェックします。もし処理すべきシグナルがあれば、カーネルはユーザスタック上に新しいフレームを構築し、あたかもユーザプロセスがシグナルハンドラ関数を自ら呼び出したかのように見せかけます。そして、ユーザモードへの復帰先を、元の実行点ではなく、シグナルハンドラのアドレスに変更します。ハンドラが終了すると、特別なシステムコール(`sigreturn`)が発行され、カーネルは保存しておいた元のコンテキストを復元し、プロセスは中断された場所から実行を再開します。' },
        { name: 'printk.c', summary: 'カーネルメッセージ出力', description: 'カーネル自身が診断メッセージやエラーメッセージを出力するための`printk()`関数を実装しています。メッセージにはログレベル（例: `KERN_ERR`, `KERN_INFO`）が付与され、カーネル内のリングバッファに保存されます。このバッファの内容は`dmesg`コマンドで閲覧でき、システムの起動時やデバイスドライバのデバッグに不可欠な情報源となります。\n\n`printk()`は、カーネルのどんなコンテキスト（プロセスコンテキスト、割り込みコンテキスト、ロック保持中など）からでも安全に呼び出せるように、非常に慎重に設計されています。コンソールへの出力は時間がかかる可能性があるため、`printk()`はまずメッセージをリングバッファに書き込むだけで素早くリターンし、実際のコンソールへの書き出しは、安全なコンテキスト（通常は専用のカーネルスレッド）で後から非同期に行われます。' },
        { name: 'module.c', summary: 'ロード可能カーネルモジュール', description: 'カーネルを再起動することなく、動的に機能（主にデバイスドライバやファイルシステム）を追加・削除するための、ロード可能カーネルモジュール(.koファイル)の仕組みを管理します。モジュールのロード(`insmod`)、アンロード(`rmmod`)、モジュール間のシンボル（関数や変数）の依存関係解決、パラメータの受け渡しなどを担当します。これにより、Linuxカーネルはモノリシックカーネルでありながら、高い拡張性と柔軟性を実現しています。\n\nモジュールがロードされる際、カーネルはモジュール内のELF（Executable and Linkable Format）セクションを解釈し、コードとデータをカーネルメモリに配置します。次に、モジュールが要求するシンボル（他のモジュールやカーネル本体がエクスポートしている関数など）を解決し、アドレスを再配置（リロケーション）します。全ての依存関係が満たされると、モジュールの初期化関数（`module_init`で登録）が呼び出されます。アンロード時は、まず終了関数（`module_exit`）が呼び出され、その後リソースが解放されます。' },
        { name: 'futex.c', summary: '高速ユーザースペースミューテックス', description: '`futex()` (Fast Userspace Mutex) システムコールの実装です。これは、ユーザースペースで効率的な同期プリミティブ(ミューテックスやセマフォなど)を構築するための、低レベルなビルディングブロックです。ロックの取得や解放が競合しない限り、アトミックなメモリ操作だけで完結し、コストの高いシステムコールを呼び出す必要がありません。競合が発生した場合にのみカーネルに遷移して、プロセスの待機や起床を管理します。glibcのNPTL (Native POSIX Thread Library) でスレッド同期のために多用されています。\n\nこの仕組みの鍵は、ユーザ空間の整数変数と、カーネル内の待機キューを関連付ける点にあります。スレッドがロックを取得しようとする際、まずユーザ空間でアトミックな比較交換(compare-and-swap)命令を試みます。成功すれば、カーネルを全く呼び出さずにロック取得が完了します。失敗した場合（つまり、ロックが既に保持されている場合）にのみ、`futex(FUTEX_WAIT, ...)`を呼び出してカーネルにスリープを要求します。ロックを解放する側は、同様にアトミック命令でロックを解放し、待機しているスレッドがいる可能性がある場合にのみ`futex(FUTEX_WAKE, ...)`を呼び出して起床させます。' },
      ],
    },
    {
      name: 'lib/',
      summary: '汎用ヘルパー関数',
      description: '特定のカーネルサブシステムに属さない、カーネル全体で再利用される汎用的なライブラリ関数が集められています。標準Cライブラリのサブセット（`strcpy`, `memcpy`, `printf`など。ただしカーネル用に安全に実装されている）、CRC計算、データ圧縮・伸張(zlib, lzo, zstd)、ソートアルゴリズム、ビットマップ操作、連結リスト操作など、コードの再利用性を高め、重複を避けるための基本的な部品が含まれています。\n\nカーネルはユーザ空間のCライブラリ（glibcなど）にリンクできないため、必要な基本的な関数を自前で実装する必要があります。ここの実装は、性能と安全性の両方が非常に重視されています。例えば、`strcpy`のようなバッファオーバーランの危険性がある関数は避け、サイズを指定する`strscpy`のような安全な代替関数が提供されています。また、`list_head`を用いた侵入型連結リストは、カーネルの至る所で使われる非常に効率的なデータ構造であり、その操作関数群もここで定義されています。',
      children: [
        { name: 'radix-tree.c', summary: 'ラディックスツリーの実装', description: '整数キー（特にポインタやインデックス）を効率的にマッピングするための、汎用的なデータ構造であるラディックスツリーを実装しています。キーをビットごとに分割し、それを辿ってツリーを探索することで、高速な検索、挿入、削除を実現します。メモリ管理サブシステムのページキャッシュ(`address_space`)が、ファイルオフセット（キー）から対応するメモリページ（値）を検索するために利用しているのが最も代表的な使用例です。\n\nラディックスツリーは、キーの範囲が広くても、実際に存在するキーが疎である場合にメモリ効率が良いという特徴があります。ツリーの高さはキーのビット数に依存しますが、子ノードへのポインタは、その下に要素が存在する場合にのみ割り当てられます。これにより、巨大な配列を使うよりもはるかに少ないメモリで、高速なインデックスアクセスを実現できます。' },
        { name: 'idr.c', summary: 'IDR/IDA (ID Radix Tree) の実装', description: '小さな整数IDをポインタにマッピングするための、ラディックスツリーをベースにした特殊な機構です。`IDR` (ID Radix) はIDからポインタへのマッピングを提供し、`IDA` (ID Allocator) は単純に未使用のIDを高速に割り当てる機能を提供します。カーネル内で、一時的にオブジェクトを一意の整数で識別する必要がある場合（例: iovecの管理、デバイス番号の割り当てなど）に広く利用され、ID空間の効率的な管理を可能にします。\n\nユーザ空間にオブジェクトを識別するためのハンドル（整数）を渡す必要がある場合、カーネル内のポインタを直接渡すのは危険です。`IDR`を使うことで、安全な整数IDを生成し、ユーザ空間に渡すことができます。ユーザ空間からそのIDが返されたら、`IDR`を使って対応する内部ポインタを安全に検索できます。これにより、カーネル内部の実装を隠蔽しつつ、安定したインターフェースを提供できます。' },
      ]
    },
    {
      name: 'mm/',
      summary: 'メモリ管理サブシステム',
      description: 'システムの物理メモリ(RAM)と、各プロセスに提供される仮想メモリを管理する、カーネルで最も複雑かつ重要なサブシステムの一つです。物理ページの割り当て（ページアロケータ）、カーネル内部で使われる小さなオブジェクト用のメモリ確保（スラブアロケータ）、各プロセスの仮想アドレス空間（`mm_struct`）の管理、ページフォールトの処理によるデマンドページング、メモリ不足時のページの解放（ページ再利用）、そしてディスク上のスワップ領域との間でページをやり取りするスワッピングなどを担当します。システムの安定性と性能に直接的な影響を与える心臓部です。\n\nこのサブシステムの中心的な役割は、有限な物理メモリを、複数のプロセスがそれぞれ持つ広大な仮想アドレス空間に、効率的かつ安全にマッピングすることです。各プロセスは、自身がメモリ全体を専有しているかのように見えますが、実際にはMMU（メモリ管理ユニット）とカーネルが連携し、必要な時に必要なページだけを物理メモリに割り当てています。この仮想化により、プロセスの分離（あるプロセスが他のプロセスのメモリを破壊できない）と、物理メモリサイズを超えるプログラムの実行が可能になります。',
      children: [
        { name: 'page_alloc.c', summary: '物理ページアロケータ', description: '物理メモリをページ(通常4KB)単位で管理し、割り当てと解放を行う基盤的なコンポーネントです。「バディシステム」アルゴリズムを用いて、2のべき乗個の連続した物理ページブロックの要求に効率的に応えます。これにより、大きな連続領域を要求された際の外部フラグメンテーション（メモリの断片化）を最小限に抑えます。物理メモリは、DMA可能な領域などの特性に応じて「ゾーン」に分割されて管理されます。\n\nバディシステムは、メモリを2^0, 2^1, 2^2, ... ページのブロックに分けて管理します。例えば、16ページの要求があった場合、まず16ページの空きブロックリストを探します。なければ、32ページのブロックを探して半分に分割し、片方を要求に応えて、もう片方を16ページの空きリストに繋ぎます。解放時は、隣接する「バディ」（分割元の相方）ブロックが空いていれば、それらを結合してより大きなブロックに戻します。この仕組みにより、大きな連続メモリの確保と解放を効率的に行います。ゾーン（例: `ZONE_DMA`, `ZONE_NORMAL`）は、古いISAデバイスのように24ビットアドレスしかアクセスできないハードウェアのために、物理メモリの低位アドレス領域を特別に管理するなどの目的で使われます。' },
        { name: 'slab_common.c', summary: 'スラブアロケータ', description: '`inode`や`dentry`、`task_struct`など、カーネル内で頻繁に生成・破棄される、比較的小さな固定サイズのオブジェクトを効率的に割り当てるためのキャッシュ機構です。物理ページアロケータの上に構築され、ページを「スラブ」と呼ばれる多数のオブジェクトの集合に分割して管理します。オブジェクトを事前に初期化しておくことで割り当てを高速化し、ページ内の未使用領域による内部フラグメンテーションを削減します。現在では、よりシンプルでスケーラブルなSLUBアロケータが主流となっています。\n\nページアロケータからページ全体を確保して、その中から小さなオブジェクトを切り出すのでは、効率が悪くフラグメンテーションも発生しやすいです。スラブアロケータは、特定の型のオブジェクト（例：`task_struct`）専用のキャッシュを作成します。オブジェクトが解放されても、そのメモリはページアロケータには返さず、キャッシュ内に保持しておき、次回の同じ型のオブジェクトの割り当て要求に即座に応えます。これにより、初期化のオーバーヘッドを削減し、CPUキャッシュの親和性を高める効果もあります。SLUBは、オリジナルのSLABアロケータの複雑さを排除し、より優れたパフォーマンスとデバッグの容易さを提供します。' },
        { name: 'memory.c', summary: '仮想メモリ管理', description: 'プロセスの仮想アドレス空間に関する中核的な機能を実装しています。最も重要なのはページフォールトハンドラ(`handle_mm_fault`)です。プロセスが、まだ物理メモリにマッピングされていない有効な仮想アドレスにアクセスすると、CPUがページフォールト例外を発生させます。このハンドラがそれを捕捉し、要求されたページを物理メモリに割り当て（必要ならディスクから読み込み）、ページテーブルを更新してプロセスを再開させます。これにより、デマンドページング(要求時ページング)が実現されます。\n\nページフォールトはエラーではありません。OSがメモリを効率的に管理するための正常な動作です。例えば、プログラム実行時、カーネルは実行ファイルの全体をメモリにロードするのではなく、単に仮想メモリ領域をセットアップするだけです。実際にそのコードやデータがアクセスされた瞬間にページフォールトが発生し、その時初めてディスクから対応する部分が物理メモリに読み込まれます。この`handle_mm_fault`は、そのフォールトが正当なものか（アクセス権はあるか、アドレスは有効か）、コピーオンライト(CoW)によるものか、あるいはディスクからの読み込みが必要かなどを判断し、適切な処理に分岐する、VMサブシステムの心臓部です。' },
        { name: 'swap.c', summary: 'スワッピングとページング', description: '物理メモリが不足した際に、使用頻度の低いメモリページ（主にファイルと関連付けられていない匿名ページ）をディスク上のスワップ領域に書き出す(ページアウト)処理と、後でそのページが必要になった際に読み戻す(ページイン)処理を管理します。これにより、物理RAMのサイズを超えるメモリをプロセスが利用できるようになりますが、低速なディスクアクセスを伴うためパフォーマンスは低下します。\n\nどのページをスワップアウトするかを決定するのは、ページ再利用のロジック(`vmscan.c`)です。ファイルに裏付けられたページ（ページキャッシュ）は、内容が変更されていなければ単に破棄するだけで済みます（必要なら後でディスクから読み直せる）。しかし、プロセスのヒープやスタックのような匿名ページは、ディスク上に実体がないため、破棄する前にスワップ領域にその内容を保存しておく必要があります。このファイルは、スワップ領域の管理（どこが空いているかなど）と、実際のページアウト/ページインのI/O操作を担当します。' },
        { name: 'filemap.c', summary: 'ページキャッシュ管理', description: 'ディスク上のファイルへのアクセスを高速化するための、極めて重要な「ページキャッシュ」を管理します。一度ディスクから読み込まれたファイルの内容はRAM上のページキャッシュに保存され、次回のアクセスはディスクI/Oなしで高速に行われます。アプリケーションがファイルに書き込んだデータも、まずページキャッシュに書き込まれ（ダーティページとなる）、後で非同期にディスクに書き戻されます（ライトバック）。\n\nページキャッシュは、VFSの`inode`オブジェクトと、それが持つ`address_space`オブジェクトを介して管理されます。`address_space`は、ファイルのオフセットをキーとして、対応する物理ページをラディックスツリーで効率的に検索できるようにします。`read()`システムコールは、まずページキャッシュを検索し、データがあればそこから直接コピーします。なければ、ページを割り当ててディスクから読み込み、ページキャッシュに追加してからユーザにデータを返します。この仕組みにより、Linuxは利用可能なメモリを最大限ディスクキャッシュとして活用し、I/O性能を向上させています。' },
        { name: 'mmap.c', summary: 'メモリマッピング', description: '`mmap()`システムコールの実装です。ファイルの内容や無名メモリ領域を、プロセスの仮想アドレス空間に直接マッピングします。これにより、`read()`/`write()`システムコールを介さずに、ポインタによるメモリアクセスで直接ファイルI/Oが可能になり、効率が向上します（メモリマップドI/O）。また、複数のプロセスが同じ物理メモリ領域を共有するための共有メモリも、この仕組みを利用して実現されます。\n\nメモリマップドI/Oでは、ファイルの内容がプロセスの仮想アドレス空間に直接現れるため、カーネルとユーザ空間の間でデータをコピーする必要がありません。プロセスがマップされた領域にアクセスすると、デマンドページングの仕組みによって、対応するファイルの内容がページキャッシュに読み込まれ、プロセスのページテーブルにマッピングされます。共有ライブラリのロードも、この`mmap`の仕組みを使って非常に効率的に実装されています。' },
        { name: 'shmem.c', summary: '共有メモリとtmpfsの実装', description: 'POSIX共有メモリ(`shm_open`)と、RAMベースのファイルシステムである`tmpfs`の両方を実装する、非常に重要なコードです。`shmem`は、ファイルシステムのインターフェースを持ちながら、実際にはディスクにデータを書き込まず、ページキャッシュ内にのみデータを保持します。メモリが不足するとスワップ領域にページアウトされることもあります。プロセス間での高速なデータ共有や、一時ファイルの置き場所として、システムの多くの場面で活用されています。\n\n`shmem`は、内部的にはページキャッシュとスワップ機構を巧みに利用しています。作成されたファイルは、inodeとdentryを持ちますが、データはすべてページキャッシュ上に存在します。これにより、ディスクI/Oを伴わない超高速なファイルシステムが実現されます。`/dev/shm`としてマウントされるのが一般的で、プロセス間で大量のデータを高速に共有したい場合に理想的なメカニズムです。' },
        { name: 'vmscan.c', summary: 'ページ再利用 (kswapd)', description: 'メモリの空き容量が少なくなってきた（メモリプレッシャーが高まった）ときに、どのメモリページを解放（またはスワップアウト）すべきかを決定するページ再利用(page reclaim)のロジックです。カーネルスレッド`kswapd`によってバックグラウンドで実行され、LRU(Least Recently Used)リストに似たアクティブ/非アクティブリストを用いて、最近使われていないページをスキャンし、解放候補を見つけ出します。システムの応答性を維持するための重要な仕組みです。\n\nカーネルは、すべてのページをアクティブリストと非アクティブリストの2つで管理します。ページがアクセスされると、アクティブリストの先頭に移動されます。`kswapd`は主に非アクティブリストの末尾からページをスキャンします。ページに最近アクセスがあれば（参照ビットが立っていれば）、アクティブリストに戻します。アクセスがなければ、そのページを解放（ページキャッシュなら破棄、匿名ページならスワップアウト）します。アクティブリストが大きくなりすぎると、その一部が非アクティブリストに移されます。この洗練されたLRU近似アルゴリズムにより、ワーキングセット（現在活発に使われているページ群）をメモリ上に保持しつつ、不要なページを効率的に解放します。' },
        { name: 'oom_kill.c', summary: 'OOM (Out of Memory) Killer', description: 'システムの物理メモリとスワップ領域が完全に枯渇し、カーネル自身が必要とするメモリすら確保できなくなった、という非常事態に呼び出される最後の砦です。このままではシステム全体がハングアップしてしまうため、ヒューリスティックな「バッドネススコア」に基づき、最も多くのメモリを消費している、あるいはシステム全体への影響が最小限で済むような、一つ以上の「悪質な」プロセスを選択して強制終了(`SIGKILL`)させ、メモリを解放します。\n\nバッドネススコアは、プロセスのメモリ使用量に比例し、実行時間やnice値などに反比例します。つまり、大量のメモリを短時間で確保した新しいプロセスほど、スコアが高くなる傾向があります。これにより、長期間安定して動作している重要なシステムデーモンよりも、暴走したアプリケーションが優先的にキルされる可能性が高まります。OOM Killerが動作するのは異常事態ですが、システム全体の完全な停止を防ぐための、最後の防衛ラインとして重要な役割を担っています。' },
        { name: 'hugetlb.c', summary: 'HugeTLBのサポート', description: '標準の4KBページよりもはるかに大きなページ(主に2MBや1GB)を管理し、アプリケーションが利用できるようにするための仕組みです。大規模なメモリ領域を連続して使用するデータベースや科学技術計算アプリケーションにおいて、仮想アドレスから物理アドレスへの変換情報をキャッシュするTLBのキャッシュヒット率を劇的に向上させ、メモリアクセス性能を改善するために利用されます。\n\nTLBは、最近使われた仮想-物理アドレス変換の結果を保持する小さな高速キャッシュです。TLBミスが発生すると、CPUはページテーブルをメモリから読み込む必要があり、大きなパフォーマンス低下を招きます。例えば、1GBのメモリ領域を4KBページでマッピングすると262,144個のTLBエントリが必要ですが、1GBの巨大ページを1つ使えば、TLBエントリは1つで済みます。これにより、TLBミスが劇的に減少し、大規模なデータセットを扱うアプリケーションの性能が大幅に向上します。' },
        { name: 'ksm.c', summary: 'Kernel Samepage Merging', description: '複数の異なるプロセスで、全く同じ内容のメモリページを動的に検出し、それらを単一の書き込み時コピー(Copy-on-Write)属性を持つ物理ページにマージして、メモリ使用量を節約する機能です。特に、同じOSの仮想マシンを多数実行するKVMホストなどで、ゲストOSの共通のライブラリページなどをマージすることで、大幅なメモリ削減効果が期待できます。`ksmd`カーネルスレッドが定期的にページをスキャンしてマージ候補を探します。\n\n`ksmd`は、マージ対象として登録された仮想メモリ領域をスキャンし、各ページのチェックサムを計算します。同じチェックサムを持つページが見つかったら、次に`memcmp()`でバイト単位の完全な比較を行います。内容が完全に一致していれば、それらのページを単一の書き込み禁止の物理ページに再マッピングします。いずれかのプロセスがそのページに書き込もうとすると、コピーオンライトの仕組みによって新しい物理ページが割り当てられ、マージが解除されます。' },
      ]
    },
    {
      name: 'net/',
      summary: 'コアネットワークスタック',
      description: 'TCP/IPをはじめとする様々なネットワークプロトコルを実装する、カーネル内で非常に重要なサブシステムです。アーキテクチャは階層化されており、下位層のネットワークデバイスドライバからパケット(`sk_buff`構造体で表現)を受け取り、リンク層(Ethernet)、ネットワーク層(IP)、トランスポート層(TCP/UDP)へと処理を渡していく入力パスと、逆にアプリケーションがソケットAPIを通じて書き込んだデータを、各層でヘッダを付加しながらパケットを構築し、ドライバに渡して送出する出力パスの両方を担当します。\n\nこのサブシステムの中心にあるのが`sk_buff`（ソケットバッファ）構造体です。これは単なるデータバッファではなく、パケットに関連するあらゆる情報（どのデバイスから来たか、どのプロトコルを経由したか、チェックサムの結果はどうか等）を保持する複雑なメタデータコンテナです。各プロトコル層は、`sk_buff`の先頭に自身のヘッダを追加（プッシュ）したり、末尾からヘッダを削除（プル）したりします。この操作は、データ本体をコピーすることなく、単にポインタを操作するだけで行えるように設計されており、ネットワーク処理のパフォーマンスを最大化するための鍵となっています。',
      children: [
        { name: 'core/', summary: 'コアネットワークインフラストラクチャ', description: '特定のプロトコル(IPv4, IPv6など)に依存しない、ネットワークスタック全体の共通基盤です。ネットワークパケットを表現する中心的なデータ構造であるソケットバッファ(`sk_buff`)の効率的な割り当て・解放・操作、ソケットの汎用的な管理、Netfilterフックの仕組み、ネットワークデバイス(`net_device`)の登録と管理など、スタック全体の土台となる機能が含まれています。\n\nこの層は、プロトコルファミリー（IPv4, IPv6, UNIXなど）とハードウェアデバイスドライバの間の、糊のような役割を果たします。`net_device`構造体は、個々のネットワークインターフェースを抽象化し、その状態や能力、そしてハードウェアにパケットを送信するための関数ポインタなどを保持します。この共通のインターフェースにより、上位のプロトコル層は、具体的なハードウェアの違いを意識することなくパケットを送受信できます。',
          children: [
            { name: 'dev.c', summary: 'ネットワークデバイス管理', description: 'システムに存在するすべてのネットワークインターフェース(`net_device`構造体)の登録・解除、状態管理(up/down)、送受信キューの制御、統計情報の収集など、ネットワークデバイス全般を管理する中心的なコードです。パケットをどのデバイスから送信するか、あるいはどのデバイスから受信したかを管理する、ハブとしての役割を果たします。\n\nドライバが初期化されると、`alloc_netdev`で`net_device`構造体を確保し、そのMACアドレスや操作関数群を設定して`register_netdevice`を呼び出します。これにより、インターフェースがシステムに認識され、`ifconfig`や`ip`コマンドで見えるようになります。パケット受信時には、ドライバが`sk_buff`を作成し、`netif_rx`を呼び出して、このコアレイヤにパケットを引き渡します。' },
            { name: 'skbuff.c', summary: 'ソケットバッファ管理', description: 'ネットワークパケットをカーネル内で表現するための極めて重要なデータ構造である`sk_buff`（ソケットバッファ）の割り当て、解放、クローン作成、ヘッダの追加・削除といった操作を行う関数群です。`sk_buff`は、パケットデータそのものだけでなく、通過したプロトコル層の情報など多くのメタデータを保持します。ゼロコピー（データコピーを避ける）送信などのパフォーマンス最適化の鍵となる部分です。\n\n`sk_buff`は、`head`と`end`ポインタで確保されたメモリ領域全体を示し、`data`と`tail`ポインタで実際のパケットデータが存在する範囲を示します。ヘッダを追加する際は`skb_push`で`data`ポインタを前にずらし、削除する際は`skb_pull`で`data`ポインタを後ろにずらします。これにより、高価な`memcpy`を伴わずにプロトコルヘッダの操作が可能になります。この巧妙な設計が、Linuxネットワークスタックの高い性能の源泉です。' },
          ]
        },
        {
          name: 'ipv4/',
          summary: 'IPv4プロトコルスタック',
          description: 'インターネットプロトコルバージョン4 (IPv4)の実装です。IPパケットのヘッダを検証し、チェックサムを計算し、ルーティングテーブルに基づいてパケットを転送（フォワーディング）または上位層（TCP/UDP）に渡すかを決定します。MTU(Maximum Transmission Unit)を超える大きなパケットの断片化(フラグメンテーション)と、受信した断片の再構築(リアセンブリ)も担当します。\n\nリンク層からIPパケットを受け取ると、まず宛先IPアドレスがローカルホストのものか、それとも他のホスト宛てのものかをチェックします。ローカル宛てであれば、パケットは上位のトランスポート層（TCPやUDP）に渡されます。他のホスト宛てで、かつIPフォワーディングが有効になっていれば、ルーティングテーブルを検索して適切な出力インターフェースとネクストホップを決定し、パケットを再送出します。このルーティングとフォワーディングの機能が、Linuxマシンをルータとして機能させることを可能にしています。',
          children: [
            { name: 'tcp_ipv4.c', summary: 'TCP for IPv4', description: '信頼性のあるコネクション指向のストリーム通信を提供するTCP (Transmission Control Protocol) の実装です。3ウェイハンドシェイクによるコネクションの確立と終了、シーケンス番号を用いた順序保証と再送制御、スライディングウィンドウによるフロー制御、そしてネットワークの混雑状況に応じて送信レートを調整する輻輳制御（CUBIC, BBRなどのアルゴリズム）といった、非常に複雑で精巧な機能が含まれています。\n\nTCPは、IPが提供する信頼性のないデータグラムサービスの上に、信頼性のあるバイトストリームを構築します。送信した各セグメントに対して受信側からの確認応答(ACK)を待ち、ACKが一定時間内に返ってこなければセグメントを再送します。フロー制御は、受信側が処理しきれないほどのデータを送信側が送らないように、受信可能なデータ量（ウィンドウサイズ）を通知する仕組みです。輻輳制御は、ネットワーク全体の混雑を検知し、パケットロスが発生した場合などに送信レートを自律的に下げることで、ネットワークの崩壊を防ぐ、インターネットの安定性を支える極めて重要なアルゴリズムです。' },
            { name: 'udp.c', summary: 'UDP for IPv4/IPv6', description: 'コネクションレスで信頼性のないデータグラム通信を提供するUDP (User Datagram Protocol) の実装です。TCPのような複雑な制御を行わないため、オーバーヘッドが非常に小さく、DNSやVoIP、オンラインゲームなど、多少のパケットロスよりもリアルタイム性が重視されるアプリケーションで広く使用されます。\n\nUDPは、IPパケットにポート番号の情報を追加するだけの、非常にシンプルなプロトコルです。順序保証も再送もないため、パケットが失われたり、順序が入れ替わって到着したりする可能性があります。これらの信頼性に関する処理は、必要であればアプリケーション層で実装する必要があります。その代わり、TCPのようなコネクション確立の遅延がなく、ヘッダが小さいため、低遅延で効率的な通信が可能です。' },
            { name: 'arp.c', summary: 'ARPプロトコル', description: 'アドレス解決プロトコル(ARP)の実装です。Ethernetのようなローカルエリアネットワーク上で、通信相手のIPアドレスに対応するMACアドレス(物理ハードウェアアドレス)を問い合わせるために使用されます。ARPリクエストをブロードキャストし、該当するホストからのARPリプライを受け取って、IPアドレスとMACアドレスの対応表（ARPキャッシュ）を維持します。\n\nIPパケットをLAN上で送信するためには、宛先のMACアドレスを知る必要があります。ルーティングテーブルでネクストホップのIPアドレスが分かっても、それだけではEthernetフレームを構築できません。そこで、まずARPリクエスト（「IPアドレスxxx.xxx.xxx.xxxを持っているのは誰ですか？」）をLAN全体に送信します。該当するホストが、自身のMACアドレスを含んだARPリプライを返信します。この結果はARPキャッシュに保存され、次回の通信からはキャッシュを使って直接通信できるようになります。' },
            { name: 'route.c', summary: 'IPv4ルーティング', description: 'IPパケットをどのネットワークインターフェースから、どのネクストホップ（次のルータ）に向けて送信すべきかを決定するための、ルーティングテーブルの管理と検索を行います。宛先IPアドレスに対してロンゲストマッチ（最も具体的な経路）するエントリを探し出し、パケットの転送先を決定します。FIB (Forwarding Information Base) と呼ばれる最適化されたデータ構造で管理されます。\n\nルーティングテーブルには、宛先ネットワーク、ネットマスク、ゲートウェイ（ネクストホップ）、出力インターフェースなどの情報が含まれています。複数の経路がマッチする場合、最もネットマスクが長い（＝最も範囲が狭く、具体的な）経路が選択されます（ロンゲストマッチ）。パフォーマンス向上のため、カーネルは検索しやすいようにルーティング情報をFIBと呼ばれるトライ木（基数木）に似たデータ構造にコンパイルしておき、パケット転送のたびに高速な検索を可能にしています。' },
          ],
        },
        { name: 'ipv6/', summary: 'IPv6プロトコルスタック', description: '事実上無限に近い広大なアドレス空間を持つ次世代インターネットプロトコル、IPv6の実装です。ARPに代わる近隣探索プロトコル(NDP)、ホストが自動的にIPアドレスを設定するステートレスアドレス自動設定(SLAAC)、拡張ヘッダのサポートなど、IPv6固有の機能が含まれています。IPv4との共存・移行技術もサポートしています。\n\nNDPは、ARPの機能だけでなく、ルータの発見、アドレスの重複検出、到達可能性の確認など、より多くの機能をICMPv6メッセージを用いて実現します。SLAACにより、DHCPサーバがなくても、ホストはルータから通知されるネットワークプレフィックスと自身のMACアドレスから、グローバルにユニークなIPv6アドレスを自動的に生成できます。これにより、ネットワーク管理が大幅に簡素化されます。' },
        { name: 'bridge/', summary: 'L2ネットワークブリッジ', description: '複数のネットワークセグメント（例えば、異なる物理Ethernetポートや仮想NIC）を、単一のレイヤー2（データリンク層）ネットワークとして接続するための、ソフトウェアによるブリッジング（スイッチング）機能の実装です。通過するパケットの送信元MACアドレスを学習してMACアドレステーブルを構築し、パケットを宛先MACアドレスが存在する適切なポートにのみ転送します。仮想化環境で仮想マシンを外部ネットワークに接続するための仮想スイッチの基盤としても広く利用されます。\n\nブリッジデバイスは、それ自身に接続されたポート（スレーブデバイス）間でEthernetフレームを転送します。未知の宛先MACアドレスを持つフレームは、受信ポート以外のすべてのポートにフラッディング（ブロードキャスト）されます。応答があると、そのMACアドレスがどのポートの先にあるかを学習し、MACアドレステーブルに記録します。これにより、次回からはそのポートにのみフレームを転送できるようになります。スパニングツリープロトコル(STP)も実装しており、ネットワークループの発生を防ぎます。' },
        { name: 'dns_resolver/', summary: 'カーネル内DNSリゾルバ', description: 'NFSやCIFSなどの一部のカーネルサブシステムが、ユーザースペースの助けを借りずに、ホスト名をIPアドレスに解決するために使用するDNSクライアント機能です。カーネル内で名前解決を完結できるため、特定の状況下で処理を簡素化できます。\n\n通常、名前解決はユーザースペースのCライブラリ（glibc）が担当し、`/etc/resolv.conf`を参照してDNSサーバに問い合わせます。しかし、例えばルートファイルシステムをNFSでマウントする場合など、ユーザースペースがまだ完全に機能していない段階で名前解決が必要になることがあります。このような場合に、このカーネル内リゾルバが使われます。' },
        { name: 'sched/', summary: 'ネットワークトラフィック制御', description: 'Quality of Service (QoS) を実現するため、ネットワークパケットの送信スケジューリングを管理するサブシステムです。キューイング規則(qdisc)と呼ばれるアルゴリズム（例: FIFO, FQ-CoDel, Cake）を用いて、パケットを異なるクラスに分類し、優先順位付け、帯域制限、シェーピングなどを行います。`tc`コマンドでユーザースペースから制御します。\n\nデフォルトでは、ネットワークデバイスは単純なFIFO（先入れ先出し）キューを使用しますが、これにより、大量のデータを転送する一つのフローが、対話的なSSHセッションのような他のフローを妨害する（バッファブロート問題）ことがあります。FQ-CoDelのような高度なqdiscは、パケットをフローごとに異なるキューに分類し、それらのキューから公平にパケットを取り出して送信します。さらに、キューの滞留時間が長くなりすぎたパケットを積極的にドロップすることで、遅延を低く抑えます。' },
        { name: 'unix/', summary: 'UNIXドメインソケット', description: '同じホスト上で動作するプロセス間通信（IPC）のための、ソケットAPIを用いた高速な通信メカニズムです。ネットワークスタックを経由せず、カーネルメモリ内で直接データをコピーするため、TCP/IPループバックよりもはるかに効率的です。ファイルシステムのパス名をアドレスとして利用します。\n\nTCP/IPループバックでは、データが完全なネットワークスタック（TCP/IP層）を通過するため、チェックサム計算やヘッダ処理などのオーバーヘッドが発生します。UNIXドメインソケットは、これらの処理をすべてバイパスし、送信プロセスのバッファから受信プロセスのバッファへ直接データをコピーします。これにより、非常に低遅延で高スループットなIPCが実現できます。X Window Systemや多くのデーモン間通信で広く利用されています。' },
        { name: 'sctp/', summary: 'SCTPプロトコルスタック', description: 'Stream Control Transmission Protocol (SCTP) の実装です。TCPの信頼性とUDPのメッセージ指向という両方の特徴を併せ持ち、さらにマルチストリーミング（一つのコネクション内で独立した複数のストリームを管理）やマルチホーミング（一つのコネクションで複数のIPアドレスを利用して耐障害性を高める）といった高度な機能を提供します。もともとはテレフォニー信号網(SS7)をIPネットワーク上で実現するために設計されました。\n\nマルチストリーミング機能は、TCPのヘッドオブラインブロッキング問題を解決します。TCPでは、一つのパケットが失われると、後続のすべてのデータが再送されるまでブロックされます。SCTPでは、ストリームは独立しているため、あるストリームでのパケットロスが他のストリームのデータ転送を妨げません。マルチホーミングは、複数のネットワーク経路を束ね、片方の経路に障害が発生しても通信を継続できる冗長性を提供します。' },
        { name: 'netfilter/', summary: 'パケットフィルタリングフレームワーク', description: 'ネットワークスタック内の定義済みの様々なポイント（フック）にコールバック関数を登録し、そこを通過するすべてのパケットを監視、改変、あるいは破棄するための、非常に強力で柔軟なフレームワークです。ユーザースペースツールの`iptables`やその後継である`nftables`は、このNetfilterフレームワークにルールを登録するためのインターフェースです。これにより、ステートフルなファイアウォール、NAT(Network Address Translation)、パケットのmangle（改変）などを実現します。\n\nNetfilterには5つの主要なフックポイントがあります：`NF_IP_PRE_ROUTING`（パケットが到着直後、ルーティング決定前）、`NF_IP_LOCAL_IN`（ローカルプロセス宛のパケット）、`NF_IP_FORWARD`（他のホストへ転送されるパケット）、`NF_IP_LOCAL_OUT`（ローカルプロセスが生成したパケット）、`NF_IP_POST_ROUTING`（パケットが送出される直前、ルーティング決定後）。`iptables`の各テーブル（filter, nat, mangle, raw）は、これらのフックポイントにルールを登録することで機能します。例えば、NATは主にPRE_ROUTINGとPOST_ROUTINGフックを利用してIPアドレスを書き換えます。' },
        { name: 'wireless/', summary: 'ワイヤレスネットワーク（Wi-Fi）', description: 'IEEE 802.11 (Wi-Fi) ネットワークをサポートするための上位レベルのサブシステムです。`cfg80211`がその中心となり、ワイヤレスデバイスの設定、利用可能なアクセスポイントのスキャン、特定のネットワークへの接続と認証の管理などを行うための共通APIを、ハードウェアドライバとユーザースペースのユーティリティ(`wpa_supplicant`など)の両方に提供します。\n\n`cfg80211`は、Wi-Fi特有の概念（SSID、BSSID、周波数、暗号化方式など）を抽象化し、標準的なインターフェースを提供します。ユーザースペースの`wpa_supplicant`デーモンは、このインターフェースを通じてスキャンを要求したり、WPA/WPA2の認証プロセスを実行したりします。`cfg80211`は、これらの要求を解釈し、下位のドライバフレームワーク（`mac80211`など）を呼び出して、実際のハードウェア操作を行います。' },
        { name: 'mac80211/', summary: 'Generic 802.11 MAC layer', description: 'Wi-Fiデバイスドライバを開発するための、ソフトウェアによる802.11 MAC (Media Access Control) 層の共通フレームワークです。SSIDの管理、ビーコンの送受信、暗号化(WEP, WPA/WPA2)、パワーセーブモードの管理など、802.11 MAC層の複雑な状態管理や処理の多くを共通化します。これにより、ドライバ開発者はハードウェア固有の低レベルな処理に集中でき、開発が大幅に簡素化されます。\n\nWi-FiのMAC層は、有線のEthernetよりもはるかに複雑です。衝突回避のためのCSMA/CA、接続状態の管理、認証・暗号化の処理など、多くのロジックを必要とします。`mac80211`は、これらの処理の大部分をソフトウェアで実装し、ハードウェアに依存しない形で提供します。ドライバは、`mac80211`が提供するコールバック関数を実装し、ハードウェアの送受信や設定変更といった基本的な操作を提供するだけで、完全なWi-Fi機能を実現できます。' },
        { name: 'bluetooth/', summary: 'Bluetoothプロトコルスタック', description: '近距離無線通信技術であるBluetoothを実現するための、BlueZプロトコルスタックのカーネル部分です。HCI (Host Controller Interface) を通じてBluetoothコントローラハードウェアと通信し、L2CAP, SCO, RFCOMMなどのコアプロトコルを実装します。これにより、ユーザースペースのアプリケーションがBluetoothデバイス（ヘッドセット、キーボードなど）との間でデータ通信を行うための基盤を提供します。\n\nHCIは、ホスト（CPU）とBluetoothコントローラ（無線チップ）間の標準的な通信プロトコルです。このディレクトリのコードは、USBやUART経由でHCIコマンドをコントローラに送信し、コントローラからのイベントを受信します。その上で、L2CAP（Logical Link Control and Adaptation Protocol）が、上位プロトコルへの多重化やパケットの分割・再構築を提供します。RFCOMMはシリアルポートをエミュレートし、SCOは音声データのような同期通信を扱います。' },
        { name: 'socket.c', summary: '汎用ソケットレイヤーAPI', description: 'ユーザースペースのアプリケーションに、標準的なバークレーソケットAPI (`socket()`, `bind()`, `connect()`, `send()`, `recv()`など) を提供する、VFSに似たインターフェース層です。アプリケーションからのシステムコールを受け取り、指定されたプロトコルファミリー(AF_INET, AF_INET6, AF_UNIXなど)とソケットタイプに応じて、TCP, UDP, UNIXドメインソケットといった具体的なプロトコル実装に処理を振り分ける、多重化・抽象化の役割を担います。\n\nこのレイヤーは、ソケットをファイルディスクリプタとして表現することで、ネットワークI/OをファイルI/Oと統一的に扱えるようにします。`socket()`システムコールが呼び出されると、このコードは`sock`構造体を割り当て、指定されたプロトコルファミリーの操作関数群（`proto_ops`）をそれに結びつけます。その後の`connect()`や`send()`といった呼び出しは、この`proto_ops`の関数ポインタを経由して、具体的なプロトコル実装（TCPなど）にディスパッチされます。この設計により、アプリケーションはプロトコルの違いを意識することなく、同じAPIで通信できます。' },
      ],
    },
    {
      name: 'samples/',
      summary: 'カーネルAPIの使用例',
      description: 'カーネルが提供する様々なAPIやサブシステムの使い方を示す、サンプルコードや小規模なデモプログラムを格納するディレクトリです。カーネル開発者が新しい機能を学ぶ際の参考資料として非常に役立ちます。`kprobes`, `tracepoints`, `eBPF`など、高度な機能の具体的な利用例が含まれており、ドキュメントだけでは理解しにくい部分を補完する役割を果たします。\n\nこれらのサンプルは、単なるスニペットではなく、コンパイル可能なカーネルモジュールやユーザースペースプログラムとして提供されています。開発者は、これらのサンプルをビルドして実行することで、APIの実際の動作を確認し、自身のコードにどのように組み込むべきかを具体的に理解することができます。新しいドライバやサブシステムを開発する際には、まずこのディレクトリで類似の機能を探すことが、良い出発点となります。',
      children: [
        { 
          name: 'bpf/',
          summary: 'eBPFプログラムのサンプル',
          description: 'eBPF (extended Berkeley Packet Filter) を利用した様々なサンプルプログラムが含まれています。ソケットフィルタリング、トレーシング、ネットワークトラフィック制御など、eBPFの強力な機能をどのように活用できるかを示す実践的なコード集です。`libbpf`ライブラリと連携し、ユーザースペースのローダープログラムとカーネル空間で実行されるeBPFプログラムの両方から構成されています。\n\nこれらのサンプルは、eBPF開発のベストプラクティスを示しています。例えば、CO-RE (Compile Once - Run Everywhere) 技術を用いて、異なるカーネルバージョン間での移植性を確保する方法や、eBPFマップを使ってカーネルとユーザースペース間で効率的にデータをやり取りする方法などが具体的に示されています。eBPFを学び始める開発者にとって、このディレクトリは宝の山と言えるでしょう。',
        },
      ]
    },
    {
      name: 'scripts/',
      summary: 'ビルドプロセス用スクリプト',
      description: 'カーネルのコンフィグレーションやビルドプロセスを補助するための、多種多様なスクリプト群(Shell, Perl, Python, Awk)です。`Kconfig`ファイルを解析して`make menuconfig`のような対話的な設定メニューを生成したり、カーネルシンボルの依存関係を解決してモジュール間のリンクを管理したり、コンパイル後のオブジェクトファイルをリンクして最終的なカーネルイメージを生成するなど、Linuxカーネルの巨大で複雑なビルド工程を自動化し、支えるための重要な役割を果たしています。\n\n例えば、`checkpatch.pl`は、提出されたパッチがLinuxカーネルのコーディングスタイル規約に従っているかをチェックするための静的解析ツールです。`get_maintainer.pl`は、変更されたファイルを引数として渡すと、そのコードの責任者であるメンテナーのリストを`MAINTAINERS`ファイルから探し出してくれる便利なスクリプトです。これらのツールは、開発プロセスの品質と効率を維持するために不可欠であり、カーネル開発のエコシステムの一部をなしています。',
    },
    {
      name: 'security/',
      summary: 'Linuxセキュリティモジュール (LSM)',
      description: '標準のLinuxのアクセス制御（ファイルパーミッションに代表される自主的アクセス制御、DAC）を強化するためのフレームワークです。カーネルの重要な内部オブジェクト(inode, task_structなど)へのアクセスが行われる直前に、セキュリティ関連のフック関数を呼び出す仕組みを提供します。SELinux, AppArmor, Smackといったセキュリティモジュールが、これらのフックを利用して、システム管理者が定義したポリシーに基づきアクセスを強制的に許可または拒否する、強制アクセス制御 (MAC) を実装します。これにより、たとえroot権限を持つプロセスであっても、その行動を厳格に制限することが可能になります。\n\nLSMは、カーネルのコアコードに直接セキュリティポリシーをハードコーディングするのではなく、フックという形で拡張ポイントを提供します。これにより、異なるセキュリティモデル（SELinuxのラベルベース、AppArmorのパス名ベースなど）をモジュールとして実装し、システム管理者が選択できるようになっています。例えば、ファイルを開く`open()`システムコールの内部で、VFSがパーミッションチェックを行った後、`security_inode_open()`のようなLSMフックが呼び出されます。ここで、アクティブなセキュリティモジュールが、独自のポリシーに基づいて追加のアクセス可否判断を下します。',
      children: [
        { name: 'selinux/', summary: 'SELinux', description: '米国国家安全保障局(NSA)によって開発された、非常に詳細で強力な強制アクセス制御(MAC)実装です。すべてのサブジェクト(プロセス)とオブジェクト(ファイル、ソケット、IPCなど)にセキュリティコンテキストと呼ばれるラベルを割り当て、システム全体で一元管理されるポリシーに基づいて、それらの間の相互作用を厳格に制御します。非常に柔軟性が高い反面、ポリシーの記述が複雑になる傾向があります。\n\nSELinuxのポリシーは、「プロセスXは、タイプYのファイルに対して、操作Zを実行することを許可する」といった形式のルールで構成されます。デフォルトのポリシーは「すべて拒否」であり、明示的に許可された操作以外はすべて禁止されます。これにより、未知の脆弱性を突いた攻撃（ゼロデイ攻撃）に対しても、被害を最小限に抑える効果が期待できます（権限昇格の防止）。Androidや多くのエンタープライズLinuxディストリビューションで、システムのセキュリティを強化するための基盤技術として採用されています。' },
        { name: 'apparmor/', summary: 'AppArmor', description: 'パス名ベースの強制アクセス制御(MAC)実装で、SELinuxよりも設定が容易であるとされています。アプリケーションごとにプロファイルを作成し、そのプログラムがアクセスできるファイルパスや、実行できる操作（ネットワークアクセス、ケーパビリティの使用など）をきめ細かく制限します。\n\nAppArmorのプロファイルは、人間が読み書きしやすい形式で記述されます。例えば、ウェブサーバのプロファイルでは、`/var/www`以下のファイルの読み取りを許可し、`/bin/bash`の実行を禁止する、といったルールを直感的に記述できます。また、学習モード（complain mode）を持っており、アプリケーションの動作を監視して、必要な権限をまとめたプロファイルのひな形を自動生成することができます。これにより、ポリシーの作成が大幅に簡素化されます。' },
      ],
    },
    {
      name: 'sound/',
      summary: 'ALSAサウンドサブシステム',
      description: 'Linuxの標準的なサウンドアーキテクチャであるALSA (Advanced Linux Sound Architecture) のカーネル部分の実装です。サウンドカードのハードウェアを抽象化し、オーディオの再生・録音、ミキサー（音量調節）制御、MIDI機能などを実現するためのAPIとフレームワークをドライバに提供します。ユーザースペースのライブラリ(alsa-lib)と連携し、複数のアプリケーションからのオーディオストリームをミキシングする機能も提供します。\n\nALSAは、サウンドカードを「カード」と、その上の「デバイス」（PCM再生、PCM録音、ミキサーなど）の集合としてモデル化します。ドライバは、ハードウェアのレジスタを操作してDMA転送をセットアップし、オーディオデータをハードウェアのリングバッファとの間でやり取りします。このサブシステムは、これらの低レベルな操作を抽象化し、`/dev/snd/`以下に標準的なキャラクタデバイスインターフェースを提供します。PulseAudioやPipeWireといった、より高レベルなサウンドサーバは、このALSAインターフェースを基盤として動作します。' ,
    },
    {
      name: 'tools/',
      summary: 'カーネル用ユーザースペースツール',
      description: 'カーネルの機能をテスト、デバッグ、または活用するための、ユーザースペースで動作するユーティリティのソースコードです。これらのツールはカーネルソースツリー内で開発・管理されており、カーネル本体と密接に連携します。最も重要なツールは`perf`で、CPUのパフォーマンスカウンタ(PMU)を利用して、システム全体のパフォーマンスを詳細にプロファイリングし、ボトルネックを特定する強力なツールです。他にも、BPF関連ツール、セルフテスト、各種カーネルインターフェースのテストツールなどが含まれます。\n\n`perf`は、単なるプロファイラではなく、Linuxのパフォーマンス分析のためのスイスアーミーナイフのような存在です。`perf record`でイベントを記録し、`perf report`で結果を分析するだけでなく、`perf stat`で特定コマンドの実行中のイベント統計を表示したり、`perf top`でリアルタイムに関数レベルのプロファイルを表示したりできます。カーネルソースツリー内で開発されているため、カーネルの最新のトレーシング機能（eBPFなど）への対応が非常に早いのが特徴です。',
    },
    {
      name: 'virt/',
      summary: '仮想化サポート（KVM）',
      description: 'カーネルベースの仮想マシン(KVM)を実装するためのコードです。KVMは、Linuxカーネル自体をタイプ1ハイパーバイザ（ベアメタルハイパーバイザ）に変える画期的な技術です。CPUが持つハードウェア仮想化支援機能(Intel VT-x, AMD-V)を直接利用して、ゲストOSのコードをホストCPU上でネイティブに近いパフォーマンスで直接実行します。メモリやI/Oの仮想化は、QEMUのようなユーザースペースのVirtual Machine Monitor (VMM) プログラムと連携して提供し、完全な仮想マシン環境を構築します。\n\nKVMは、`/dev/kvm`というキャラクタデバイスをユーザースペースに提供します。QEMUのようなVMMは、このデバイスを`ioctl`で操作して、仮想マシンの作成、仮想CPU(vCPU)の作成、ゲストのメモリレイアウトの設定などを行います。vCPUを実行するには、`KVM_RUN` ioctlを呼び出します。すると、制御がカーネル内のKVMに移り、ハードウェア支援機能を使ってゲストコードの実行を開始します。ゲストが特権操作などでVM exitを起こすと、`KVM_RUN`から制御がVMMに戻り、VMMがそのイベントをエミュレートして、再び`KVM_RUN`を呼び出します。このモデルにより、ゲストの実行という性能が重要な部分はカーネルが担当し、複雑なデバイスエミュレーションはユーザースペースのVMMが担当するという、効率的な役割分担が実現されています。',
    },
    {
      name: 'Kconfig',
      summary: 'カーネルビルドの構成オプション',
      description: 'カーネルのコンパイル時に、どの機能を有効にし、どのドライバを組み込むかを選択するための、構成オプションのデータベースです。`Kconfig`ファイルは階層的に構成されており、各機能の依存関係（例：「このドライバを有効にするには、まずI2Cバスのサポートを有効にする必要がある」）も記述されています。`make menuconfig`のようなコンフィグレーションツールは、これらのファイルを解析してユーザーに分かりやすい選択肢を提示し、その結果はプロジェクトのルートにある`.config`ファイルに保存されます。\n\n`Kconfig`言語は、`config`、`menuconfig`、`choice`といったキーワードで構成オプションを定義し、`bool`、`tristate`（組み込み(y)/モジュール(m)/無効(n)）、`string`、`int`といった型を持ちます。`depends on`キーワードで他のオプションへの依存関係を、`select`キーワードで逆方向の依存関係（これを選ぶと自動的に別のオプションも選ばれる）を定義できます。この強力な依存関係解決システムが、何万ものオプションから、矛盾のない有効なカーネルコンフィグレーションを生成することを可能にしています。',
    },
    {
      name: 'Makefile',
      summary: 'トップレベルMakefile',
      description: 'カーネル全体のビルドプロセスを制御する、最も上位に位置するMakefileです。このMakefileは、`.config`ファイルの内容を読み込んで、どのサブディレクトリをビルドの対象とするか、どのファイルをコンパイルするかを決定します。そして、`make`コマンドを再帰的に呼び出して、各サブディレクトリのMakefileを実行させていきます。最終的に、生成されたすべてのオブジェクトファイル(`.o`)をリンクして、`vmlinux`（ELF形式のカーネルイメージ）や`bzImage`（圧縮されたブート可能イメージ）といった最終的なカーネルイメージを生成します。\n\nこのMakefileは非常に巨大で複雑ですが、その中心的な役割は、`.config`ファイル内の`CONFIG_FOO=y`や`CONFIG_FOO=m`といった設定を、ビルドターゲットに変換することです。例えば、`CONFIG_EXT4_FS=y`なら`fs/ext4/`ディレクトリがビルド対象になり、`CONFIG_EXT4_FS=m`なら`fs/ext4/ext4.ko`というモジュールが生成されます。`obj-$(CONFIG_FOO)`という形式の変数が多用され、コンフィグレーションに応じてビルド対象となるオブジェクトファイルのリストを動的に構築します。この仕組みが、カーネルの高度なカスタマイズ性を支えています。',
    },
    {
      name: 'COPYING',
      summary: 'Linuxカーネルのライセンス',
      description: 'Linuxカーネルが準拠するライセンス、GNU General Public License, version 2 (GPL-2.0)の全文が記載されています。このライセンスは、誰でも自由にソースコードを使用、変更、再配布できる自由を保証する一方で、カーネルのコードを改変して作成した派生物も、同じGPL-2.0ライセンスでソースコードを公開することを義務付けています（コピーレフト）。これが、Linuxのオープンな発展を法的に支える基盤となっています。\n\nGPLv2の重要な点は、カーネルと動的にリンクされるロード可能カーネルモジュールも、一般的にはカーネルの派生物と見なされるという点です。これにより、プロプライエタリ（非公開ソース）なデバイスドライバをカーネルモジュールとして配布することには、法的な議論の余地があります。カーネルコミュニティは、`EXPORT_SYMBOL_GPL`というマクロを提供し、特定のカーネル内部APIをGPL互換ライセンスのモジュールからしか利用できないようにすることで、GPLの精神を維持しようと努めています。',
    },
     {
      name: 'README',
      summary: 'カーネルに関する基本情報',
      description: 'Linuxカーネルとは何か、そしてカーネルをコンパイルしてインストールするための基本的な手順についての簡単な説明が書かれています。プロジェクトの目的や、より詳細なドキュメントへのポインタも含まれており、新しい開発者やユーザーが最初に目を通すべきドキュメントの一つです。\n\nこのファイルは、カーネルを初めて扱う人にとっての出発点です。必要最低限のビルド手順（`make menuconfig`, `make`, `make modules_install`, `make install`など）が簡潔に説明されています。また、バグ報告の方法や、開発コミュニティ（メーリングリストなど）への参加方法についても触れられており、Linuxカーネルの世界への入り口としての役割を果たしています。',
    },
    {
      name: 'MAINTAINERS',
      summary: 'メンテナーリスト',
      description: 'カーネルの各サブシステム、ドライバ、アーキテクチャの品質と開発に責任を持つ「メンテナー」のリストです。特定のコード領域に対するパッチ（変更提案）を送る際や、技術的な質問がある場合に、誰に連絡すればよいか（メーリングリストや個人のメールアドレス）を知るための、開発プロセスにおいて非常に重要なファイルです。\n\nLinuxカーネルの開発は、Linus Torvaldsを頂点とする階層的な信頼の網(Web of Trust)に基づいています。各サブシステムのメンテナーは、その分野の専門家として、提出されたパッチをレビューし、品質を保証し、自身のgitツリーに取り込みます。そして、定期的にその変更をLinusにプルリクエストとして送ります。このファイルは、その分散型開発モデルの「誰が何を担当しているか」という地図そのものであり、開発のスムーズな進行に不可欠です。',
    },
    {
      name: 'CREDITS',
      summary: '貢献者リスト',
      description: 'Linus Torvalds氏をはじめ、長年にわたりLinuxカーネルの開発に多大な貢献をした数百人もの主要な開発者の名前を（不完全ながらも）リストアップしたものです。これは、Linuxが一個人の成果ではなく、世界中の多くの開発者の協力によって成り立っている巨大な共同作業の産物であることを示す、プロジェクトの歴史そのものです。\n\n現代のカーネル開発では、すべてのコミットに作者情報が記録されるため、このファイルが網羅的な貢献者リストとして更新されることは少なくなりました。しかし、プロジェクトの初期から中期にかけて、Linuxを形作ってきたパイオニアたちの名前がここに刻まれており、Linuxの歴史を物語る貴重なドキュメントとしての価値を持っています。',
    },
  ],
};